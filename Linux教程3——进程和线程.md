# Linux教程3——进程和线程

出处: https://subingwen.cn/linux/

# 一、进程控制

## 1.1 进程概述

从严格意义上来讲，程序和进程是两个不同的概念，他们的状态，占用的系统资源都是不同的。

- **程序**：就是磁盘上的可执行文件文件, 并且只占用磁盘上的空间，是一个**静态**的概念。
- **进程**：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的**内存**，**CPU资源**，每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个**动态**的概念

### 1.1.1 并行和并发

- **CPU时间片**

  CPU在某个时间点只能处理一个任务，但是操作系统都支持多任务的，那么在计算机CPU只有一个的情况下是怎么完成多任务处理的呢？原理和古时候救济灾民的思路是一样的，每个人分一点，但是又不叫吃饱。

  **CPU会给每个进程被分配一个时间段**，进程得到这个时间片之后才可以运行，使各个程序从表面上看是同时进行的。**如果在时间片结束时进程还在运行，CPU的使用权将被收回，该进程将会被中断挂起等待下一个时间片。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换**，这样就可以避免CPU资源的浪费。

  因此可以得知，在我们使用的计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于CPU一次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，我们感觉不到罢了，因此CPU的核数越多计算机的处理效率越高。

- **并发**和**并行**

  这两个概念呢都可以笼统的解释为：多个进程同时运行，但是他们两个的同时并不是同一个概念。Erlang 之父 Joe Armstrong 用一张5岁小孩都能看懂的图解释了并发与并行的区别：


[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/Concurrency-vs-Parallelism.png)](https://subingwen.cn/linux/process/Concurrency-vs-Parallelism.png)

> **并发**：第一幅图是**并发**。

- 并发的同时运行是一个假象，咖啡机也好CPU也好在某一个时间点只能为某一个个体来服务，因此不可能同时处理多任务，这是通过上图的咖啡机/计算机的CPU快速的时间片切换实现的。

- 并发是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。
- 并发也可以理解为是一个屌丝通过不断努力自我升华的结果。

> **并行**：第二幅图是**并行**。

- 并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程

- 并行需要依赖多个硬件资源，单个是无法实现的（图中有两台咖啡机）。
- 并行可以理解为是一个高富帅，出生就有天然的硬件优势，资源多自然办事效率就高。

### 1.1.2 PCB

> **PCB** - **进程控制块**（**Processing Control Block**），Linux内核的进程控制块本质上是一个叫做 **task_struct**的结构体。在这个结构体中记录了进程运行相关的一些信息，下面介绍一些常用的信息：

- **进程id**：每一个进程都一个唯一的进程ID，类型为 pid_t, 本质是一个整形数
- **进程的状态**：进程有不同的状态, 状态是一直在变化的，有就绪、运行、挂起、停止等状态。
- **进程对应的虚拟地址空间的信息**。
- **描述控制终端的信息**，进程在哪个终端启动默认就和哪个终端绑定。
- **当前工作目录**：默认情况下, 启动进程的目录就是当前的工作目录
- **umask掩码**：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。
- **文件描述符表**：每个被分配的文件描述符都对应一个已经打开的磁盘文件
- **和信号相关的信息**：在Linux中 **调用函数**, **键盘快捷键**, **执行shell命令**等操作都会产生信号。
  - **阻塞信号集**：记录当前进程中阻塞哪些已产生的信号，使其不能被处理
- **未决信号集**：记录在当前进程中产生的哪些信号还没有被处理掉。
- **用户id和组id**：当前进程属于哪个用户, 属于哪个用户组
- **会话（Session）和进程组**：多个进程的集合叫进程组，多个进程组的集合叫会话。
- **进程可以使用的资源上限**：可以使用shell命令**ulimit -a**查看详细信息。

### 1.1.4 进程状态

进程一共有五种状态分别为：**创建态**，**就绪态**，**运行态**，**阻塞态**(**挂起态**)，**退出态**(**终止态**)其中**创建态**和**退出态**维持的时间是非常短的，稍纵即逝。我们主要是需要将**就绪态**, **运行态**, **挂起态**，三者之间的状态切换搞明白。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/1557237111672.png)](https://subingwen.cn/linux/process/1557237111672.png)

- 就绪态: 万事俱备，只欠东风（**CPU资源**）

  - 进程被创建出来了，有运行的资格但是还没有运行，需要抢CPU时间片
  - 得到CPU时间片，进程开始运行，从就绪态转换为运行态。
  - 进程的CPU时间片用完了, 再次失去CPU, 从运行态转换为就绪态。
- 运行态：获取到CPU资源的进程，进程只有在这种状态下才能运行
  - 运行态不会一直持续，进程的CPU时间片用完之后, 再次失去CPU，从运行态转换为就绪态
  - 只要进程还没有退出，就会在就绪态和运行态之间不停的切换。
- 阻塞态：进程被强制放弃CPU，并且没有抢夺CPU时间片的资格
  - 比如: 在程序中调用了某些函数（比如: sleep()），进程又运行态转换为阻塞态（挂起态）
  - 当某些条件被满足了（比如：slee() 睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。
- 退出态: 进程被销毁, 占用的系统资源被释放了
  - 任何状态的进程都可以直接转换为退出态。

### 1.1.5 进程命令

在研究如何创建进程之前，先来看一下如何在终端中通过命令完成进程相关的操作。

- 查看进程

```shell
$ ps aux
	- a: 查看所有终端的信息
	- u: 查看用户相关的信息
	- x: 显示和终端无关的进程信息
```

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210203171636845.png)](https://subingwen.cn/linux/process/image-20210203171636845.png)

如果特别想知道每个参数控制着哪些信息, 可以通过 **ps** **a**, **ps u**, **ps x**分别查看。

- 杀死进程

**kill**命令可以发送某个信号到对应的进程，进程收到某些信号之后默认的处理动作就是退出进程，如果要给进程发送信号，可以先查看一下Linux给我们提供了哪些标准信号

> 查看Linux中的标准信号:

```shell
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

> 9号信号（SIGKILL）的行为是**无条件杀死进程**，想要杀死哪个进程就可以把这个信号发送给这个进程，操作如下：

```shell
# 无条件杀死进程, 进程ID通过 ps aux 可以查看
$ kill -9 进程ID
$ kill -SIGKILL 进程ID
```

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210203172310788.png)](https://subingwen.cn/linux/process/image-20210203172310788.png)

## 1.2 进程创建

### 1.2.1 函数

Linux中进程**ID**为 **pid_t** 类型，其本质是一个**正整数**，通过上边的**ps aux**命令已经得到了验证。PID为1的进程是Linux系统中创建的第一个进程。

- 获取**当前进程**的进程ID（**PID**）

```c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
```

- 获取**当前进程的父进程** ID（**PPID**）

```c
#include <sys/types.h>
#include <unistd.h>
pid_t getppid(void);
```

- 创建一个**新的进程**

```c
#include <unistd.h>
pid_t fork(void);
```

> Linux中看似创建一个新的进程非常简单，函数连参数都没有，实际上如果想要真正理解这个函数还是得死几个脑细胞。
>

### 1.2.2 fork() 剖析

```c
pid_t fork(void);
```

启动磁盘上的应用程序, 得到一个进程, 如果在这个启动的进程中调用**fork()**函数，就会得到一个新的进程，我们习惯将其称之为**子进程**。前面说过每个进程都对应一个属于自己的虚拟地址空间，**子进程的地址空间是基于父进程的地址空间拷贝出来的**，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的，下图是拷贝之后父子进程各自的虚拟地址空间：

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210203181255536.png)](https://subingwen.cn/linux/process/image-20210203181255536.png)

- **相同点**：

  ​	**拷贝完成之后**（**注意这个时间点**），**两个地址空间中的用户区数据是相同的**。用户区数据主要数据包括：

  - **代码区**：默认情况下父子进程地址空间中的源代码始终相同。
  - **全局数据区**：父进程中的全局变量和变量值全部被拷贝一份放到了子进程地址空间中
  - **堆区**：父进程中的堆区变量和变量值全部被拷贝一份放到了子进程地址空间中
  - **动态库加载区**（**内存映射区**）：父进程中数据信息被拷贝一份放到了子进程地址空间中
  - **栈区**：父进程中的栈区变量和变量值全部被拷贝一份放到了子进程地址空间中
  - **环境变量**：默认情况下，父子进程地址空间中的环境变量始终相同。
  - **文件描述符表**: **父进程中被分配的文件描述符都会拷贝到子进程中，在子进程中可以使用它们打开对应的文件**。

- **区别**：

  - 父子进程各自的**虚拟地址空间是相互独立的**，不会互相干扰和影响。

  - 父子进程地址空间中代码区代码虽然相同，但是父子进程执行的代码逻辑可能是不同的。

  - 由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完成之后，**全局数据区**, **栈区**, **堆区**, **动态库加载区**(**内存映射区**)数据会各自发生变化，由于地址空间是相互独立的，因此不会互相覆盖数据。

  - 由于每个进都有自己的进程ID，因此内核区存储的父子进程ID是不同的。

  - 进程启动之后进入就绪态，运行需要争抢CPU时间片而且可能执行不同的业务逻辑，所以父子进程的状态可能是不同的。

  - **fork() 调用成功之后，会返回两个值，父子进程的返回值是不同的**。

    - **该函数调用成功之后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将 fork() 的返回值记录下来**，这就是为什么会得到两个返回值的原因。

    - 父进程的虚拟地址空间中将该返回值标记为一个大于0的数（其实记录的是子进程的进程ID）

    - 子进程的虚拟地址空间中将该返回值标记 0

    - **在程序中需要通过 fork() 的返回值来判断当前进程是子进程还是父进程**。

      ```c
      int main()
      {
          // 在父进程中创建子进程
          pid_t pid = fork();
          printf("当前进程fork()的返回值: %d\n", pid);
          if(pid > 0)
          {
              // 父进程执行的逻辑
              printf("我是父进程, pid = %d\n", getpid());
          }
          else if(pid == 0)
          {
              // 子进程执行的逻辑
              printf("我是子进程, pid = %d, 我爹是: %d\n", getpid(), getppid());
          }
          else // pid == -1
          {
              // 创建子进程失败了
          }
          
          // 不加判断, 父子进程都会执行这个循环
          for(int i=0; i<5; ++i)
          {
              printf("%d\n", i);
          }
          
          return 0;
      }
      ```

## 1.3 父子进程

### 1.3.1 进程执行位置

在父进程中成功创建了子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行的呢？**父进程肯定是从main()函数开始运行的，子进程是在父进程中调用fork()函数之后被创建, 子进程就从fork()之后开始向下执行代码**。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210203210603208.png)](https://subingwen.cn/linux/process/image-20210203210603208.png)

上图中演示了父子进程中代码的执行流程，可以看到如果在程序中对**fork()**的返回值做了判断，就可以控制父子进程的行为，如果没有做任何判断这个代码块父子进程都可以执行。在编写多进程程序的时候，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，并且多份数据中变量名都相同，但是他们的值却不一定相同。

### 1.3.2 循环创建子进程

掌握了进程创建函数之后，实现一个简单的功能，在一个父进程中循环创建3个子进程，也就是最后需要得到4个进程，1个父进程，3个子进程，为了方便验证程序的正确性，要求在程序中打印出每个进程的进程ID。

下面是编写的代码：

```c
// process_loop.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main()
{
    for(int i=0; i<3; ++i)
    {
        pid_t pid = fork();
        printf("当前进程pid: %d\n", getpid());
    }

    return 0;
}
```

编译并执行上面的代码，得到了如下结果：

```shell
# 编译
$ gcc process_loop.c

# 执行
$ ./a.out
# 最终得到了 8个进程
当前进程pid: 18774     ------ 1
当前进程pid: 18774     ------ 1
当前进程pid: 18774     ------ 1
当前进程pid: 18777     ------ 2
当前进程pid: 18776     ------ 3
当前进程pid: 18776     ------ 3
当前进程pid: 18775     ------ 4
当前进程pid: 18775     ------ 4
当前进程pid: 18775     ------ 4
当前进程pid: 18778     ------ 5
当前进程pid: 18780     ------ 6
当前进程pid: 18779     ------ 7
当前进程pid: 18779     ------ 7
当前进程pid: 18781     ------ 8
```

通过程序打印的信息发现程序循环了三次，最终得到了8个进程，也就是创建出了7个子进程，还是上面跟大家讲的那句话，对应多进程的程序，一定要代码分成很多份去分析，并且如果没有在程序中加条件控制，所有的代码父子进程都是有资格执行的。接下来分析上边的编写的代码，通过画图的方式分析为什么得到了7个子进程：

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20191229121508802.png)](https://subingwen.cn/linux/process/image-20191229121508802.png)

上图中的树状结构，**蓝色节点代表父进程**：

- 循环第一次 i = 0，创建出一个子进程，即红色节点，子进程变量值来自父进程拷贝，因此 i=0

- 循环第二次 i = 1，蓝色父进程和红色子进程都去创建子进程，得到两个紫色进程，子进程变量值来自父进程拷贝，因此 i=1
- 循环第三次 i = 2，蓝色父进程和红色、紫色子进程都去创建子进程，因此得到4个绿色子进程，子进程变量值来自父进程拷贝，因此 i=2
- 循环第三次 i = 3，所有进程都不满足条件 **for(int i=0; i<3; ++i)**因此不进入循环，退出了。

**通过上面的分析，最终得到解决方案，我们可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，因此只需要在程序中添加关于父子进程的判断即可**。

修改之后的代码如下：

```c
// 需要在上边的程序中控制不让子进程, 再创建子进程即可
// process_loop.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main()
{
    pid_t pid;
    // 在循环中创建子进程
    for(int i=0; i<3; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            // 不让子进程执行循环, 直接跳出
            break;
        }
    }
    printf("当前进程pid: %d\n", getpid());

    return 0;
}
```

最后编译并执行程序，查看最终结果，可以看到最后确实得到了4个不同的进程，pid最小的为父进程，其余为子进程：

```shell
# 编译
$ gcc process_loop.c

# 执行
$ ./a.out
当前进程pid: 2727
当前进程pid: 2730
当前进程pid: 2729
当前进程pid: 2728
```

> 在多进程序中，进程的执行顺序是没有规律的，因为所有的进程都需要在就绪态争抢CPU时间片，抢到了就执行，抢不到就不执行，但是不用担心，默认进程的优先级是相同的，操作系统不会让某一个进程一直抢不到CPU时间片。
>

### 1.3.3 终端显示问题

在执行多进程程序的时候，经常会遇到下图中的问题，看似进程还没有执行完成，貌似是因为什么原因被阻塞了，实际上终端是正常的，当我们通过键盘输入一些命令，终端也能接受输入并且输出相关信息，那么为什么终端会显示成这个样子呢？

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210203215938828.png)](https://subingwen.cn/linux/process/image-20210203215938828.png)

1. a.out 进程启动之后，共创建了3个子进程，其实 a.out 也是有父进程的就是当前的终端

2. 终端只能检测到 a.out 进程的状态，a.out执行期间终端切换到后台，a.out执行完毕之后终端切换回前台

3. 当终端切换到前之后，a.out的子进程还没有执行完毕，当子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题，但是此时终端是可以接收键盘输入的，只是看起来不美观而已。

4. 想要解决这个问题，需要让所有子进程退出之后再退出父进程，比如：在父进程代码中调用 sleep()

   ```c
   pid_t pid = fork();
   if(pid > 0)
   {
       sleep(3);	// 让父进程睡一会儿
   }
   else if(pid == 0)
   {
       // 子进程
   }
   ```

### 1.3.4 进程数数

思考一个问题，当父进程创建一个子进程，那么父子进程之间可以通过全局变量互动，实现交替数数的功能吗？不过不确定可以写一段测试代码：

```c
// number.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

// 定义全局变量
int number = 10;

int main()
{
    printf("创建子进程之前 number = %d\n", number);

    pid_t pid = fork();
    // 父子进程都会执行这一行
    printf("当前进程fork()的返回值: %d\n", pid);

    //如果是父进程
    if(pid > 0)
    {
        printf("我是父进程, pid = %d, number = %d\n", getpid(), ++number);
        printf("父进程的父进程(终端进程), pid = %d\n", getppid());
        sleep(1);
    }
    else if(pid == 0)
    {
        // 子进程
        number += 100;
        printf("我是子进程, pid = %d, number = %d\n", getpid(), number);
        printf("子进程的父进程, pid = %d\n", getppid());
    }

    return 0;
}
```


编译程序并测试:

```shell
$ gcc number.c
$ ./a.out 
创建子进程之前 number = 10
当前进程fork()的返回值: 3513
当前进程fork()的返回值: 0
我是子进程, pid = 3513, number = 110
子进程的父进程, pid = 3512

我是父进程, pid = 3512, number = 11	# 没有接着子进程的110继续数,父子进程各玩各的,测试失败了
父进程的父进程(终端进程), pid = 2175
```

> 通过验证得到**结论**：**两个进程中是不能通过全局变量实现数据交互的，因为每个进程都有自己的地址空间，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。如果要进行进程间通信需要使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式**。
>

## 1.4 execl和execlp函数

在项目开发过程中，有时候有这种需求，需要通过现在运行的进程启动磁盘上的另一个可执行程序，也就是通过一个进程启动另一个进程，这种情况下我们可以使用 **exec族函数**，函数原型如下：

```c
#include <unistd.h>

extern char **environ;
int execl(const char *path, const char *arg, ...
          /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
           /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
           /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
            char *const envp[]);
```

**这些函数执行成功后不会返回**，因为调用进程的实体，包括**代码段**，**数据段**和**堆栈**等都已经被新的内容取代（**也就是说用户区数据基本全部被替换掉了**），只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有**调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行**。

> 也就是说 **exec族** 函数并没有创建新进程的能力，只是有大无畏的牺牲精神，让起启动的新进程寄生到自己虚拟地址空间之内，并挖空了自己的地址空间用户区，把新启动的进程数据填充进去。
>

**exec族**函数中最常用的有两个**execl()**和**execlp()**，这两个函数是对其他4个函数做了进一步的封装，下面介绍一下。

### 1.4.1 execl()

该函数可用于执行任意一个可执行程序，**函数需要通过指定的文件路径才能找到这个可执行程序**。

```c
#include <unistd.h>
// 变参函数
int execl(const char *path, const char *arg, ...);
```

- **参数**:
  - **path**: 要启动的可执行程序的路径, 推荐使用**绝对路径**
  - **arg**: **ps aux** 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同
  - **...** : 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。
- **返回值**：如果这个函数执行成功, 没有返回值，如果执行失败, 返回 -1

### 1.4.2 execlp()

该函数常用于执行已经设置了环境变量的可执行程序，函数中的 **p** 就是**path**，也是说这个函数会自动搜索系统的环境变量**PATH**，因此使用这个函数执行可执行程序不需要指定路径，只需要指定出名字即可。

```c
// p == path
int execlp(const char *file, const char *arg, ...);
```

- **参数**:
  - **file**: 可执行程序的名字
    - 在环境变量PATH中，可执行程序可以不加路径
    - 没有在环境变量PATH中, 可执行程序需要指定绝对路径
  - **arg**: ps aux 查看进程的时候, 启动的进程的名字, 可以随意指定, 一般和要启动的可执行程序名相同
  - **...** : 要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。
- **返回值**：如果这个函数执行成功, 没有返回值，如果执行失败, 返回 -1

### 1.4.3 函数的使用

关于exec族函数，我们一般不会在进程中直接调用，如果直接调用这个进程的代码区代码被替换也就不能按照原来的流程工作了。**我们一般在调用这些函数的时候都会先创建一个子进程，在子进程中调用 exec 族函数，子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程不受任何影响仍然可以继续正常工作**。

execl() 或者 execlp() 函数的**使用方法**如下:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>


int main()
{
    // 创建子进程
    pid_t pid = fork();
    // 在子进程中执行磁盘上的可执行程序
    if(pid == 0)
    {
        // 磁盘上的可执行程序 /bin/ps
#if 1
        execl("/bin/ps", "title", "aux", NULL);
        // 也可以这么写
        // execl("/bin/ps", "title", "a", "u", "x", NULL);  
#else
        execlp("ps", "title", "aux", NULL);
        // 也可以这么写
        // execl("ps", "title", "a", "u", "x", NULL);
#endif
        // 如果成功当前子进程的代码区别 ps中的代码区代码替换
        // 下面的所有代码都不会执行
        // 如果函数调用失败了,才会继续执行下面的代码
        perror("execl");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
        printf("++++++++++++++++++++++++\n");
    }
    else if(pid > 0)
    {
        printf("我是父进程.....\n");
    }

    return 0;
}
```

[![image-20210204123455742](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210204123455742.png)](https://subingwen.cn/linux/process/image-20210204123455742.png)

## 1.5 进程控制

进程控制主要是指 **进程的退出**, **进程的回收**和 进程的特殊状态 孤**儿进程**和**僵尸进程**。

### 1.5.1 结束进程

如果想要直接退出某个进程可以在程序的任何位置调用**exit()**或者**_exit()**函数。函数的参数相当于退出码, 如果参数值为 0 程序退出之后的状态码就是0, 如果是100退出的状态码就是100。

```c
// 专门退出进程的函数, 在任何位置调用都可以
// 标准C库函数
#include <stdlib.h>
void exit(int status);

// Linux的系统函数
// 可以这么理解, 在linux中 exit() 函数 封装了 _exit()
#include <unistd.h>
void _exit(int status);
```

在 main 函数中直接使用 **return**也可以退出进程, 假如是在一个普通函数中调用 return 只能返回到调用者的位置，而不能退出进程。

```c
// ***** return 必须要在main()函数中调用, 才能退出进程 *****
// 举例:
// 没有问题的例子
int main()
{
    return 0;	// 进程退出了
}

////////////////////////// 不能退出的例子 //////////////////////////

int func()
{
    return 666;	// 返回到调用者调用该函数的位置, 返回到 main() 函数的第19行
}

int main()
{
    // 调用这个函数, 当前进程能不能退出? ===> 不能
    int ret = func();
}
```

### 1.5.2 孤儿进程

在一个启动的进程中创建子进程，这时候父子进程同时运行，但是父进程由于某种原因先退出了，子进程还在运行，这时候这个子进程就可以被称之为**孤儿进程**（跟现实是一样的）。

操作系统是非常关爱运行的每一个进程的，当检测到某一个进程变成了孤儿进程，这时候系统中就会有一个固定的进程领养这个孤儿进程（有干爹了）。如果使用Linux没有桌面终端，这个领养孤儿进程的进程就是 **init 进程（PID=1）**，如果有**桌面终端**，这个领养孤儿进程就是**桌面进程**。

那么问题来了，系统为什么要领养这个孤儿进程呢？**在子进程退出的时候, 进程中的用户区可以自己释放, 但是进程内核区的pcb资源自己无法释放，必须要由父进程来释放子进程的pcb资源，孤儿进程被领养之后，这件事儿干爹就可以代劳了，这样可以避免系统资源的浪费**。

下面这段代码就可以得到一个孤儿进程：

```c
int main()
{
    // 创建子进程
    pid_t pid = fork();

    // 父进程
    if(pid > 0)
    {
        printf("我是父进程, pid=%d\n", getpid());
    }
    else if(pid == 0)
    {
        sleep(1);	// 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程
        // 子进程
        printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
```

```shell
# 程序输出的结果
$ ./a.out 
我是父进程, pid=22459
我是子进程, pid=22460, 父进程ID: 1		# 父进程向退出, 子进程变成孤儿进程, 子进程被1号进程回收
```

### 1.5.3 僵尸进程

在一个启动的进程中创建子进程，这时候就有了父子两个进程，父进程正常运行, 子进程先于父进程结束, 子进程无法释放自己的PCB资源, 需要父进程来做这个件事儿, 但是如果父进程也不管, 这时候子进程就变成了**僵尸进程**。

> **僵尸进程**不能将它看成是一个正常的进程，这个进程已经死亡了，用户区资源已经被释放了，只是还占用着一些内核资源（PCB）。 僵尸进程就相当于是一副已经腐烂只剩下骨头的尸体。
>
> **僵尸进程**的出现是**由于这个已死亡的进程的父进程不作为造成的**。

运行下面的代码就可以得到一个僵尸进程了：

```c
int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        // 一直运行不退出, 并且也做回收, 就会出现僵尸进程
        while(1)
        {
            printf("我是父进程, pid=%d\n", getpid());
            sleep(1);
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
```

```shell
# ps aux 查看进程信息
# Z+ --> 这个进程是僵尸进程, defunct, 表示进程已经死亡
robin     22598  0.0  0.0   4352   624 pts/2    S+   10:11   0:00 ./app
robin     22599  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22600  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22601  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22602  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
robin     22603  0.0  0.0      0     0 pts/2    Z+   10:11   0:00 [app] <defunct> # 子进程
```

> 消灭僵尸进程的方法是，杀死这个僵尸进程的父进程，这样僵尸进程的资源就被系统回收了。通过 ==**kill -9**==僵尸进程PID的方式是不能消灭僵尸进程的，这个命令只对活着的进程有效，僵尸进程已经死了，鞭尸是不能解决问题的。
>

### 1.5.4 进程回收

为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收，回收方式有两种，一种是**阻塞方式wait()**，一种是**非阻塞方式waitpid()**。

#### 1.5.4.1 wait

这是个**阻塞函数**，如果没有子进程退出, 函数会一直阻塞等待, 当检测到子进程退出了, 该函数阻塞解除回收子进程资源。这个函数被调用一次, 只能回收一个子进程的资源，如果有多个子进程需要资源回收, 函数需要被调用多次。

函数原型如下：

```c
// man 2 wait
#include <sys/wait.h>

pid_t wait(int *status);
```

- **参数**：传出参数，通过传递出的信息判断回收的进程是怎么退出的，如果不需要该信息可以指定为 NULL。取出整形变量中的数据需要使用一些宏函数，具体操作方式如下：
  - **WIFEXITED(status)**: 返回1, 进程是正常退出的
    - **WEXITSTATUS(status)**：得到进程退出时候的状态码，相当于 return 后边的数值, 或者 exit()函数的参数
  - **WIFSIGNALED(status)**: 返回1, 进程是被信号杀死了
    - **WTERMSIG(status)**: 获得进程是被哪个信号杀死的，会得到信号的编号
- **返回值**:
  - **成功**：返回被回收的子进程的进程ID
  - **失败**: -1
    - 没有子进程资源可以回收了, 函数的阻塞会自动解除, 返回-1
    - 回收子进程资源的时候出现了异常


下面代码演示了如何通过 **wait()** 回收多个子进程资源：

```c
// wait 函数回收子进程资源
#include <sys/wait.h>

int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        while(1)
        {
            // 回收子进程的资源
            // 子进程由多个, 需要循环回收子进程资源
            pid_t ret = wait(NULL);
            if(ret > 0)
            {
                printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
            }
            else
            {
                printf("回收失败, 或者是已经没有子进程了...\n");
                break;
            }
            printf("我是父进程, pid=%d\n", getpid());
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
```

#### 1.5.4.2 waitpid

**waitpid()** 函数可以看做是 **wait()** 函数的升级版，通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。

该函数函数原型如下：

```c
// man 2 waitpid
#include <sys/wait.h>
// 这个函数可以设置阻塞, 也可以设置为非阻塞
// 这个函数可以指定回收哪些子进程的资源
pid_t waitpid(pid_t pid, int *status, int options);
```

- **参数**:
  - **pid**:
    - **-1**：回收所有的子进程资源, 和wait()是一样的, 无差别回收，并不是一次性就可以回收多个, 也是需要循环回收的
    - **大于0**：指定回收某一个进程的资源 ，pid是要回收的子进程的进程ID
    - **0**：回收当前进程组的所有子进程ID
    - **小于 -1**：pid 的绝对值代表进程组ID，表示要回收这个进程组的所有子进程资源
  - **status**: NULL, 和wait的参数是一样的
  - **options**: 控制函数是阻塞还是非阻塞
    - **0**: 函数是行为是阻塞的 ==> 和wait一样
    - **WNOHANG**: 函数是行为是非阻塞的
- **返回值**:
  - 如果函数是非阻塞的, 并且子进程还在运行, 返回0
  - 成功: 得到子进程的进程ID
  - 失败: -1
    - 没有子进程资源可以回收了, 函数如果是阻塞的, 阻塞会解除, 直接返回-1
    - 回收子进程资源的时候出现了异常


下面代码演示了如何通过 waitpid()阻塞回收多个子进程资源：

```c
// 和wait() 行为一样, 阻塞
#include <sys/wait.h>

int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        while(1)
        {
            // 回收子进程的资源
            // 子进程由多个, 需要循环回收子进程资源
            int status;
            pid_t ret = waitpid(-1, &status, 0);  // == wait(NULL);
            if(ret > 0)
            {
                printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
                                // 判断进程是不是正常退出
                if(WIFEXITED(status))
                {
                    printf("子进程退出时候的状态码: %d\n", WEXITSTATUS(status));
                }
                if(WIFSIGNALED(status))
                {
                    printf("子进程是被这个信号杀死的: %d\n", WTERMSIG(status));
                }
            }
            else
            {
                printf("回收失败, 或者是已经没有子进程了...\n");
                break;
            }
            printf("我是父进程, pid=%d\n", getpid());
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("===我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
```

下面代码演示了如何通过 waitpid()非阻塞回收多个子进程资源：

```c
// 非阻塞处理
#include <sys/wait.h>

int main()
{
    pid_t pid;
    // 创建子进程
    for(int i=0; i<5; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    // 父进程
    if(pid > 0)
    {
        // 需要保证父进程一直在运行
        while(1)
        {
            // 回收子进程的资源
            // 子进程由多个, 需要循环回收子进程资源
            // 子进程退出了就回收, 
            // 没退出就不回收, 返回0
            int status;
            pid_t ret = waitpid(-1, &status, WNOHANG);  // 非阻塞
            if(ret > 0)
            {
                printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
                // 判断进程是不是正常退出
                if(WIFEXITED(status))
                {
                    printf("子进程退出时候的状态码: %d\n", WEXITSTATUS(status));
                }
                if(WIFSIGNALED(status))
                {
                    printf("子进程是被这个信号杀死的: %d\n", WTERMSIG(status));
                }
            }
            else if(ret == 0)
            {
                printf("子进程还没有退出, 不做任何处理...\n");
            }
            else
            {
                printf("回收失败, 或者是已经没有子进程了...\n");
                break;
            }
            printf("我是父进程, pid=%d\n", getpid());
        }
    }
    else if(pid == 0)
    {
        // 子进程, 执行这句代码之后, 子进程退出了
        printf("===我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
    }
    return 0;
}
```

# 二、管道

## 2.1 管道

管道的是**进程间通信**（**IPC - InterProcess Communication**）的一种方式，管道的**本质其实就是内核中的一块内存(或者叫内核缓冲区)，这块缓冲区中的数据存储在一个环形队列中，因为管道在内核里边，因此我们不能直接对其进行任何操作**。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png)](https://subingwen.cn/linux/pipe/循环队列.png)

因为管道数据是通过队列来维护的，我们先来分析一个管道中数据的**特点**：

- 管道对应的内核缓冲区大小是固定的，**默认为4k**（也就是队列最大能存储4k数据）

- 管道分为两部分：**读端**和**写端**（队列的两端），数据从写端进入管道，从读端流出管道。

- 管道中的数据**只能读一次**，做一次读操作之后数据也就没有了（读数据相当于**出队列**）。

- 管道是**单工**的：数据只能**单向流动**, 数据**从写端流向读**端。

- 对管道的操作（读、写）默认是**阻塞的**

  - **读管道**：管道中没有数据，读操作被阻塞，当管道中有数据之后阻塞才能解除
  - **写管道**：管道被写满了，写数据的操作被阻塞，当管道变为不满的状态，写阻塞解除

管道在内核中, 不能直接对其进行操作，我们通过什么方式去读写管道呢？其实管道操作就是文件IO操作，内核中管道的两端分别对应两个文件描述符，通过写端的文件描述符把数据写入到管道中，通过读端的文件描述符将数据从管道中读出来。读写管道的函数就是Linux中的文件IO函数

```c
// 读管道
ssize_t read(int fd, void *buf, size_t count);
// 写管道的函数
ssize_t write(int fd, const void *buf, size_t count);
```

最后分析一下为什么可以使用管道进行进程间通信，先看一下下面的图片：

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210204211818071.png)](https://subingwen.cn/linux/pipe/image-20210204211818071.png)

在上图中假设父进通过一系列操作可以通过文件描述符表中的文件描述符**fd3写管道**，通过**fd4读管道**，然后再**通过 fork() 创建出子进程，那么在父进程中被分配的文件描述符 fd3， fd4也就被拷贝到子进程中，子进程通过 fd3可以将数据写入到内核的管道中，通过fd4将数据从管道中读出来**。

也就是说**管道是独立于任何进程的**，并且充当了两个进程用于数据通信的载体，只要两个进程能够得到同一个管道的入口和出口（读端和写端的文件描述符），那么他们之间就可以通过管道进行数据的交互。

## 2.2. 匿名管道

### 2.2.1 创建匿名管道

**匿名管道**是管道的一种，既然是匿名也就是说这个管道没有名字，但其本质是不变的，就是位于内核中的一块内存，匿名管道拥有上面介绍的管道的所有特性，额外的我们需要知道，**匿名管道只能实现有血缘关系的进程间通信**，什么叫有血缘的进程关系呢，比如：父子进程，兄弟进程，爷孙进程，叔侄进程。最后说一下创建匿名管道的函数，函数原型如下：

```c
#include <unistd.h>
// 创建一个匿名的管道, 得到两个可用的文件描述符
int pipe(int pipefd[2]);
```

- **参数**：传出参数，需要传递一个整形数组的地址，数组大小为 2，也就是说最终会传出两个元素
  - **pipefd[0]: 对应管道读端的文件描述符，通过它可以将数据从管道中读出**
  - **pipefd[1]: 对应管道写端的文件描述符，通过它可以将数据写入到管道中**
- **返回值**：成功返回 0，失败返回 -1

### 2.2.2 进程间通信

使用匿名管道只能够实现有血缘关系的进程间通信，要求写一段程序完成下边的功能：

```
需求描述:
   在父进程中创建一个子进程, 父子进程分别执行不同的操作:
     - 子进程: 执行一个shell命令 "ps aux", 将命令的结果传递给父进程
     - 父进程: 将子进程命令的结果输出到终端
```

需求分析:

- 子进程中执行shell命令相当于启动一个磁盘程序，因此需要使用 execl()/execlp()函数

  - execlp(“ps”, “ps”, “aux”, NULL)
- 子进程中执行完shell命令直接就可以在终端输出结果，如果将这些信息传递给父进程呢？
  - 数据传递需要使用管道，子进程需要将数据写入到管道中
  - 将默认输出到终端的数据写入到管道就需要进行输出的重定向，需要使用 dup2()做这件事情
    - dup2(fd[1], STDOUT_FILENO);
- 父进程需要读管道，将从管道中读出的数据打印到终端
- 父进程最后需要释放子进程资源，防止出现僵尸进程

在使用管道进行进程间通信的注意事项：**必须要保证数据在管道中的单向流动**。这句话怎么理解呢，通过下面的图来分析一下：

> 第一步: 在父进程中创建了匿名管道，得到了两个分配的文件描述符，fd3操作管道的读端，fd4操作管道的写端。
>

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210204223438269.png)](https://subingwen.cn/linux/pipe/image-20210204223438269.png)

> 第二步：父进程创建子进程，父进程的文件描述符被拷贝，在子进程的文件描述符表中也得到了两个被分配的可以使用的文件描述符，通过fd3读管道，通过fd4写管道。通过下图可以看到管道中数据的流动不是单向的，有以下这么几种情况：
>
> 1. 父进程通过fd4将数据写入管道，然后父进程再通过fd3将数据从管道中读出
>
> 2. 父进程通过fd4将数据写入管道，然后子进程再通过fd3将数据从管道中读出
> 3. 子进程通过fd4将数据写入管道，然后子进程再通过fd3将数据从管道中读出
> 4. 子进程通过fd4将数据写入管道，然后父进程再通过fd3将数据从管道中读出
>
> 前边说到过，管道行为默认是阻塞的，**假设子进程通过写端将数据写入管道，父进程的读端将数据读出，这样子进程的读端就读不到数据，导致子进程阻塞在读管道的操作上**，这样就会给程序的执行造成一些不必要的影响。如果我们本来也没有打算让进程读或者写管道，那么就可以将进程操作的读端或者写端关闭。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210204224031041.png)](https://subingwen.cn/linux/pipe/image-20210204224031041.png)

> 第三步：为了避免两个进程都读管道，但是可能其中某个进程由于读不到数据而阻塞的情况，我们可以关闭进程中用不到的那一端的文件描述符，这样数据就只能单向的从一端流向另外一端了，如下图，我们关闭了父进程的写端，关闭了子进程的读端：
>

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210204225930296.png)](https://subingwen.cn/linux/pipe/image-20210204225930296.png)

根据上面的分析，最终可以写出下面的代码：

```c
// 管道的数据是单向流动的:
// 操作管道的是两个进程, 进程A读管道, 需要关闭管道的写端, 进程B写管道, 需要关闭管道的读端
// 如果不做上述的操作, 会对程序的结果造成一些影响, 对管道的操作无法结束
#include <fcntl.h>
#include <sys/wait.h>

int main()
{
    // 1. 创建匿名管道, 得到两个文件描述符
    int fd[2];
    int ret = pipe(fd);
    if(ret == -1)
    {
        perror("pipe");
        exit(0);
    }
    // 2. 创建子进程 -> 能够操作管道的文件描述符被复制到子进程中
    pid_t pid = fork();
    if(pid == 0)
    {
        // 关闭读端
        close(fd[0]);
        // 3. 在子进程中执行 execlp("ps", "ps", "aux", NULL);
        // 在子进程中完成输出的重定向, 原来输出到终端现在要写管道
        // 进程打印数据默认输出到终端, 终端对应的文件描述符: stdout_fileno
        // 标准输出 重定向到 管道的写端
        dup2(fd[1], STDOUT_FILENO);
        execlp("ps", "ps", "aux", NULL);
        perror("execlp");
    }

    // 4. 父进程读管道
    else if(pid > 0)
    {
        // 关闭管道的写端
        close(fd[1]);
        // 5. 父进程打印读到的数据信息
        char buf[4096];
        // 读管道
        // 如果管道中没有数据, read会阻塞
        // 有数据之后, read解除阻塞, 直接读数据
        // 需要循环读数据, 管道是有容量的, 写满之后就不写了
        // 数据被读走之后, 继续写管道, 那么就需要再继续读数据
        while(1)
        {
            memset(buf, 0, sizeof(buf));
            int len = read(fd[0], buf, sizeof(buf));
            if(len == 0)
            {
                // 管道的写端关闭了, 如果管道中没有数据, 管道读端不会阻塞
                // 没数据直接返回0, 如果有数据, 将数据读出, 数据读完之后返回0
                break;
            }
            printf("%s, len = %d\n", buf, len);
        }
        close(fd[0]);

        // 回收子进程资源
        wait(NULL);
    }
    return 0;
}
```

## 2.3 有名管道

### 2.3.1 创建有名管道

**有名管道**拥有管道的所有特性，之所以称之为有名是因为管道在磁盘上有实体文件, **文件类型为p** ，**有名管道文件大小永远为0，因为有名管道也是将数据存储到内存的缓冲区中，打开这个磁盘上的管道文件就可以得到操作有名管道的文件描述符，通过文件描述符读写管道存储在内核中的数据**。

有名管道也可以称为 **fifo** (**first in first out**)，使用有名管道既可以进行有血缘关系的进程间通信，也可以进行没有血缘关系的进程间通信。创建有名管道的方式有两种，一种是通过命令，一种是通过函数。

- 通过命令

  ```c
  $ mkfifo 有名管道的名字
  ```

- 通过函数

- ```c
  #include <sys/types.h>
  #include <sys/stat.h>
  // int open(const char *pathname, int flags, mode_t mode);
  int mkfifo(const char *pathname, mode_t mode);
  ```

  - **参数**:
    - **pathname**: 要创建的有名管道的名字
    - **mode**: 文件的操作权限, 和open()的第三个参数一个作用，最终权限: (mode & ~umask)
  - **返回值**：创建成功返回 0，失败返回 -1

### 2.3.2 进程间通信

不管是有血缘关系还是没有血缘关系，使用有名管道实现进程间通信的方式是相同的，就是在两个进程中分别以读、写的方式打开磁盘上的管道文件，得到用于读管道、写管道的文件描述符，就可以调用对应的read()、write()函数进行读写操作了。

> 小贴士：
> **有名管道操作需要通过 open() 操作得到读写管道的文件描述符，如果只是读端打开了或者只是写端打开了，进程会阻塞在这里不会向下执行，直到在另一个进程中将管道的对端打开，当前进程的阻塞也就解除了。所以当发现进程阻塞在了open()函数上不要感到惊讶**。

- 写管道的进程

  ```c
  /*
  	1. 创建有名管道文件 
  		mkfifo()
  	2. 打开有名管道文件, 打开方式是 o_wronly
  		int wfd = open("xx", O_WRONLY);
  	3. 调用write函数写文件 ==> 数据被写入管道中
  		write(wfd, data, strlen(data));
  	4. 写完之后关闭文件描述符
  		close(wfd);
  */
  ```

  ```c
  #include <fcntl.h>
  #include <sys/stat.h>
  
  int main()
  {
      // 1. 创建有名管道文件
      int ret = mkfifo("./testfifo", 0664);
      if(ret == -1)
      {
          perror("mkfifo");
          exit(0);
      }
      printf("管道文件创建成功...\n");
  
      // 2. 打开管道文件
      // 因为要写管道, 所有打开方式, 应该指定为 O_WRONLY
      // 如果先打开写端, 读端还没有打开, open函数会阻塞, 当读端也打开之后, open解除阻塞
      int wfd = open("./testfifo", O_WRONLY);
      if(wfd == -1)
      {
          perror("open");
          exit(0);
      }
      printf("以只写的方式打开文件成功...\n");
  
      // 3. 循环写管道
      int i = 0;
      while(i<100)
      {
          char buf[1024];
          sprintf(buf, "hello, fifo, 我在写管道...%d\n", i);
          write(wfd, buf, strlen(buf));
          i++;
          sleep(1);
      }
      close(wfd);
  
      return 0;
  }
  ```

- 读管道的进程

  ```c
  /*
  	1. 这两个进程需要操作相同的管道文件
  	2. 打开有名管道文件, 打开方式是 o_rdonly
  		int rfd = open("xx", O_RDONLY);
  	3. 调用read函数读文件 ==> 读管道中的数据
  		char buf[4096];
  		read(rfd, buf, sizeof(buf));
  	4. 读完之后关闭文件描述符
  		close(rfd);
  */
  ```

  ```c
  #include <fcntl.h>
  #include <sys/stat.h>
  
  int main()
  {
      // 1. 打开管道文件
      // 因为要read管道, so打开方式, 应该指定为 O_RDONLY
      // 如果只打开了读端, 写端还没有打开, open阻塞, 当写端被打开, 阻塞就解除了
      int rfd = open("./testfifo", O_RDONLY);
      if(rfd == -1)
      {
          perror("open");
          exit(0);
      }
      printf("以只读的方式打开文件成功...\n");
  
      // 2. 循环读管道
      while(1)
      {
          char buf[1024];
          memset(buf, 0, sizeof(buf));
          // 读是阻塞的, 如果管道中没有数据, read自动阻塞
          // 有数据解除阻塞, 继续读数据
          int len = read(rfd, buf, sizeof(buf));
          printf("读出的数据: %s\n", buf);
          if(len == 0)
          {
              // 写端关闭了, read解除阻塞返回0
              printf("管道的写端已经关闭, 拜拜...\n");
              break;
          }
  
      }
      close(rfd);
  
      return 0;
  }
  ```

## 2.4. 管道的读写行为

关于管道不管是有名的还是匿名的，在进行读写的时候，它们表现出的行为是一致的，下面是对其读写行为的总结:

- **读管道**，需要根据写端的状态进行分析：
  - 写端没有关闭 (操作管道写端的文件描述符没有被关闭)
    - 如果管道中没有数据 ==> **读阻塞**, 如果管道中被写入了数据, 阻塞解除
    - 如果管道中有数据 ==> 不阻塞，管道中的数据被读完了, 再继续读管道还会阻塞
  - 写端已经关闭了 (没有可用的文件描述符可以写管道了)
    - 管道中没有数据 ==> 读端解除阻塞, read函数返回0
    - 管道中有数据 ==> read先将数据读出, 数据读完之后返回0, 不会阻塞了
- **写管道**，需要根据读端的状态进行分析：
  - 读端没有关闭
    - 如果管道有存储的空间, 一直写数据
    - 如果管道写满了, 写操作就阻塞, 当读端将管道数据读走了, 解除阻塞继续写
  - 读端关闭了，管道破裂(异常), 进程直接退出

> 管道的两端默认是阻塞的，如何将管道设置为非阻塞呢？管道的读写两端的非阻塞操作是相同的，下面的代码中将匿名的读端设置为了非阻塞：
>

```c
// 通过fcntl 修改就可以, 一般情况下不建议修改
// 管道操作对应两个文件描述符, 分别是管道的读端 和 写端

// 1. 获取读端的文件描述符的flag属性
int flag = fcntl(fd[0], F_GETFL);
// 2. 添加非阻塞属性到 flag中
flag |= O_NONBLOCK;
// 3. 将新的flag属性设置给读端的文件描述符
fcntl(fd[0], F_SETFL, flag);
// 4. 非阻塞读管道
char buf[4096];
read(fd[0], buf, sizeof(buf));
```

# 三、内存映射(mmap)

## 3.1 创建内存映射区

如果想要实现**进程间通信**，可以通过函数创建一块内存映射区，和管道不同的是管道对应的内存空间在内核中，而内存映射区对应的内存空间在进程的用户区（用于加载动态库的那个区域），也就是说 **进程间通信使用的内存映射区不是一块，而是在每个进程内部都有一块**。

由于每个进程的地址空间是独立的，各个进程之间也不能直接访问对方的内存映射区，需要通信的进程需要将各自的内存映射区和同一个磁盘文件进行映射，这样进程之间就可以通过磁盘文件这个唯一的桥梁完成数据的交互了。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210205145238501.png)](https://subingwen.cn/linux/mmap/image-20210205145238501.png)

如上图所示：`磁盘文件数据可以完全加载到进程的内存映射区也可以部分加载到进程的内存映射区，当进程A中的内存映射区数据被修改了，数据会被自动同步到磁盘文件，同时和磁盘文件建立映射关系的其他进程内存映射区中的数据也会和磁盘文件进行数据的实时同步，这个同步机制保障了各个进程之间的数据共享。`

使用内存映射区既可以进程有血缘关系的进程间通信也可以进程没有血缘关系的进程间通信。创建内存映射区的函数原型如下：

```c
#include <sys/mman.h>
// 创建内存映射区
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

- **参数**:
  - **addr**: 从动态库加载区的什么位置开始创建内存映射区，一般指定为NULL, 委托内核分配
    - **length**: 创建的内存映射区的大小（单位：字节），实际上这个大小是按照4k的整数倍去分配的
    - **prot**: 对内存映射区的操作权限
      - **PROT_READ**: 读内存映射区
      - **PROT_WRITE**: 写内存映射区
      - 如果要对映射区有读写权限: PROT_READ | PROT_WRITE
  - **flags**:
    - **MAP_SHARED**: 多个进程可以共享数据，进行映射区数据同步
    - **MAP_PRIVATE**: 映射区数据是私有的，不能同步给其他进程
  - **fd**: 文件描述符, 对应一个打开的磁盘文件，内存映射区通过这个文件描述符和磁盘文件建立关联
  - **offset**: 磁盘文件的偏移量，文件从偏移到的位置开始进行数据映射，使用这个参数需要注意两个问题：
    - 偏移量必须是4k的整数倍, 写0代表不偏移
    - 这个参数必须是大于 0 的
- **返回值:**
  - **成功**: 返回一个内存映射区的起始地址
  - **失败**: `MAP_FAILED` (that is, (void *) -1)

**mmap()** 函数的参数相对较多，在使用该函数创建用于进程间通信的内存映射区的时候，各参数的指定都有一些注意事项，具体如下：

```c
1. 第一个参数 addr 指定为 NULL 即可
2. 第二个参数 length 必须要 > 0
3. 第三个参数 prot，进程间通信需要对内存映射区有读写权限，因此需要指定为：PROT_READ | PROT_WRITE
4. 第四个参数 flags，如果要进行进程间通信, 需要指定 MAP_SHARED
5. 第五个参数 fd，打开的文件必须大于0，进程间通信需要文件操作权限和映射区操作权限相同
     - 内存映射区创建成功之后, 关闭这个文件描述符不会影响进程间通信
6. 第六个参数 offset，不偏移指定为0，如果偏移必须是4k的整数倍
```

内存映射区使用完之后也需要释放，释放函数原型如下：

```c
int munmap(void *addr, size_t length);
```

- **参数**:
  - **addr**: mmap()的返回值, 创建的内存映射区的起始地址
  - **length**: 和mmap()第二个参数相同即可
- **返回值**：函数调用成功返回 0，失败返回 -1

## 3.2 进程间通信

操作内存映射区和操作管道是不一样的，得到内存映射区之后是直接对内存地址进行操作，管道是通过文件描述符读写队列中的数据，管道的读写是阻塞的，内存映射区的读写是非阻塞的。内存映射区创建成功之后，得到了映射区内存的起始地址，使用相关的内存操作函数读写数据就可以了。

### 3.2.1 有血缘关系

由于创建子进程会发生虚拟地址空间的复制，那么在父进程中创建的内存映射区也会被复制到子进程中，这样在子进程里边就可以直接使用这块内存映射区了，所以对于有血缘关系的进程，进行进程间通信是非常简单的，处理代码如下：

```c
/*
    1. 先创建内存映射区, 得到一个起始地址, 假设使用ptr指针保存这个地址
    2. 通过fork() 创建子进程 -> 子进程中也就有一个内存映射区, 子进程中也有一个ptr指针指向这个地址
    3. 父进程往自己的内存映射区写数据, 数据同步到了磁盘文件中, 磁盘文件数据又同步到子进程的映射区中
       子进程从自己的映射区往外读数据, 这个数据就是父进程写的
*/
```

```c
#include <sys/mman.h>
#include <fcntl.h>

int main()
{
    // 1. 打开一个磁盘文件
    int fd = open("./english.txt", O_RDWR);
    // 2. 创建内存映射区
    void* ptr = mmap(NULL, 4000, PROT_READ|PROT_WRITE,
                     MAP_SHARED, fd, 0);
    if(ptr == MAP_FAILED)
    {
        perror("mmap");
        exit(0);
    }

    // 3. 创建子进程
    pid_t pid = fork();
    if(pid > 0)
    {
        // 父进程, 写数据
        const char* pt = "我是你爹, 你是我儿子吗???";
        memcpy(ptr, pt, strlen(pt)+1);
    }
    else if(pid == 0)
    {
        // 子进程, 读数据
        usleep(1);	// 内存映射区不阻塞, 为了让子进程读出数据
        printf("从映射区读出的数据: %s\n", (char*)ptr);
    }

    // 释放内存映射区
    munmap(ptr, 4000);

    return 0;
}
```

### 3.2.2 没有血缘关系

对于没有血缘关系的进程间通信，需要在每个进程中分别创建内存映射区，但是这些进程的内存映射区必须要关联相同的磁盘文件，这样才能实现进程间的数据同步。

> 进程A的测试代码:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>

int main()
{
    // 1. 打开一个磁盘文件
    int fd = open("./english.txt", O_RDWR);
    // 2. 创建内存映射区
    void* ptr = mmap(NULL, 4000, PROT_READ|PROT_WRITE,
                     MAP_SHARED, fd, 0);
    if(ptr == MAP_FAILED)
    {
        perror("mmap");
        exit(0);
    }
    
    const char* pt = "==================我是你爹, 你是我儿子吗???****************";
    memcpy(ptr, pt, strlen(pt)+1);

    // 释放内存映射区
    munmap(ptr, 4000);

    return 0;
}
```

> 进程B的测试代码:
>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>

int main()
{
    // 1. 打开一个磁盘文件
    int fd = open("./english.txt", O_RDWR);
    // 2. 创建内存映射区
    void* ptr = mmap(NULL, 4000, PROT_READ|PROT_WRITE,
                     MAP_SHARED, fd, 0);
    if(ptr == MAP_FAILED)
    {
        perror("mmap");
        exit(0);
    }

    // 读内存映射区
    printf("从映射区读出的数据: %s\n", (char*)ptr);

    // 释放内存映射区
    munmap(ptr, 4000);

    return 0;
}
```

## 3.3 拷贝文件

使用内存映射区除了可以实现进程间通信，也可以进行文件的拷贝，使用这种方式拷贝文件可以减少程序猿的工作量，我们只需要负责创建内存映射区和打开磁盘文件，关于文件中的数据读写就无需关心了。

> 使用内存映射区拷贝文件思路：
>
> 1. 打开被拷贝文件，得到文件描述符 fd1，并计算出这个文件的大小 size
> 2. 创建内存映射区A并且和被拷贝文件关联，也就是和fd1关联起来，得到映射区地址 ptrA
> 3. 创建新文件，得到文件描述符 fd2，用于存储被拷贝的数据，并且将这个文件大小拓展为 size
> 4. 创建内存映射区B并且和新创建的文件关联，也就是和fd2关联起来，得到映射区地址 ptrB
> 5. 进程地址空间之间的数据拷贝，memcpy（ptrB， ptrA，size），数据自动同步到新建文件中
> 6. 关闭内存映射区

文件拷贝示例代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>

int main()
{
    // 1. 打开一个操盘文件english.txt得到文件描述符
    int fd = open("./english.txt", O_RDWR);
    // 计算文件大小
    int size = lseek(fd, 0, SEEK_END);

    // 2. 创建内存映射区和english.txt进行关联, 得到映射区起始地址
    void* ptrA = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if(ptrA == MAP_FAILED)
    {
        perror("mmap");
        exit(0);
    }

    // 3. 创建一个新文件, 存储拷贝的数据
    int fd1 = open("./copy.txt", O_RDWR|O_CREAT, 0664);
    // 拓展这个新文件
    ftruncate(fd1, size);

    // 4. 创建一个映射区和新文件进行关联, 得到映射区的起始地址second
    void* ptrB = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd1, 0);
    if(ptrB == MAP_FAILED)
    {
        perror("mmap----");
        exit(0);
    }
    // 5. 使用memcpy拷贝映射区数据
    // 这两个指针指向两块内存, 都是内存映射区
    // 指针指向有效的内存, 拷贝的是内存中的数据
    memcpy(ptrB, ptrA, size);

    // 6. 释放内存映射区
    munmap(ptrA, size);
    munmap(ptrB, size);
    close(fd);
    close(fd1);

    return 0;
}
```

# 四、共享内存

共享内存不同于内存映射区，它不属于任何进程，并且不受进程生命周期的影响。通过调用Linux提供的系统函数就可得到这块共享内存。使用之前需要让进程和共享内存进行关联，得到共享内存的起始地址之后就可以直接进行读写操作了，进程也可以和这块共享内存解除关联, 解除关联之后就不能操作这块共享内存了。在所有进程间通信的方式中共享内存的效率是最高的。

> 共享内存操作默认不阻塞，如果`多个进程同时读写共享内存`，可能出现数据混乱，共享内存需要借助其他机制来保证进程间的数据同步，比如：信号量，共享内存内部没有提供这种机制。

## 4.1 创建/打开共享内存

### 4.1.1 shmget

在使用共享内存之前必须要先做一些准备工作，如果共享内存不存在就需要先创建出来，如果已经存在了就需要先打开这块共享内存。不管是创建还是打开共享内存使用的函数是同一个，函数原型如下:

```c
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(key_t key, size_t size, int shmflg);
```

- **参数**:
  - **key**: 类型 key_t 是个整形数, `通过这个key可以创建或者打开一块共享内存，该参数的值一定要大于0`
  - **size**: 创建共享内存的时候, 指定共享内存的大小，如果是打开一块存在的共享内存, size是没有意义的
  - **shmflg**：创建共享内存的时候指定的属性
    - **IPC_CREAT**: 创建新的共享内存，如果创建共享内存, 需要指定对共享内存的操作权限，比如：IPC_CREAT | 0664
    - **IPC_EXCL**: 检测共享内存是否已经存在了，必须和 IPC_CREAT一起使用
- **返回值**：共享内存创建或者打开成功返回标识共享内存的唯一的ID，失败返回-1

函数使用举例:

> 场景1：创建一块大小为4k的共享内存

```c
shmget(100, 4096, IPC_CREAT|0664);
```

> 场景2：创建一块大小为4k的共享内存, 并且检测是否存在
>

```c
// 	如果共享内存已经存在, 共享内存创建失败, 返回-1, 可以perror() 打印错误信息
shmget(100, 4096, IPC_CREAT|0664|IPC_EXCL);
```

> 场景3：打开一块已经存在的共享内存
>

```c
// 函数参数虽然指定了大小和IPC_CREAT, 但是都不起作用, 因为共享内存已经存在, 只能打开, 参数4096也没有意义
shmget(100, 4096, IPC_CREAT|0664);
shmget(100, 0, 0);
```

> 场景4：打开一块共享内存, 如果不存在就创建
>

```c
shmget(100, 4096, IPC_CREAT|0664);
```

### 4.1.2 ftok

**shmget()** 函数的第一个参数是一个大于0的正整数，如果不想自己指定可以通过 ftok()函数直接生成这个key值。该函数的函数原型如下：

```c
// ftok函数原型
#include <sys/types.h>
#include <sys/ipc.h>

// 将两个参数作为种子, 生成一个 key_t 类型的数值
key_t ftok(const char *pathname, int proj_id);
```

- **参数**:
  - b: 当前操作系统中一个存在的路径
  - **proj_id**: 这个参数只用到了int中的一个字节, 传参的时候要将其作为 char 进行操作，取值范围: 1-255
- **返回值**：函数调用成功返回一个可用于创建、打开共享内存的key值，调用失败返回-1

使用举例：

```c
// 根据路径生成一个key_t
key_t key = ftok("/home/robin", 'a');
// 创建或打开共享内存
shmget(key, 4096, IPC_CREATE|0664);
```

## 4.2 关联和解除关联

### 4.2.1 shmat

创建/打开共享内存之后还必须和共享内存进行关联，这样才能得到共享内存的起始地址，通过得到的内存地址进行数据的读写操作，关联函数的原型如下：

```c
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

- **参数**:
  - **shmid**: 要操作的共享内存的ID, 是 shmget() 函数的返回值
  - **shmaddr**: 共享内存的起始地址, 用户不知道, 需要让内核指定, 写NULL
  - **shmflg**: 和共享内存关联的对共享内存的操作权限
    - **SHM_RDONLY**: 读权限, 只能读共享内存中的数据
    - **0**: 读写权限，可以读写共享内存数据
- **返回值**：关联成功，返回值共享内存的起始地址，关联失败返回 (void *) -1

### 4.2.2 shmdt

当进程不需要再操作共享内存，可以让进程和共享内存解除关联，另外如果没有执行该操作，进程退出之后，结束的进程和共享内存的关联也就自动解除了。

```c
int shmdt(const void *shmaddr);
```

- **参数**：shmat() 函数的返回值, 共享内存的起始地址
- **返回值**：关联解除**成功返回0，失败返回-1**

## 4.3 删除共享内存

### 4.3.1 shmctl

**shmctl()** 函数是一个多功能函数，可以设置、获取共享内存的状态也可以将共享内存标记为删除状态。`当共享内存被标记为删除状态之后，并不会马上被删除，直到所有的进程全部和共享内存解除关联，共享内存才会被删除。`因为通过shmctl()函数只是能够标记删除共享内存，所以在程序中多次调用该操作是没有关系的。

```c
// 共享内存控制函数
int shmctl(int shmid, int cmd, struct shmid_ds *buf);

// 参数 struct shmid_ds 结构体原型          
struct shmid_ds {
	struct ipc_perm shm_perm;    /* Ownership and permissions */
	size_t          shm_segsz;   /* Size of segment (bytes) */
	time_t          shm_atime;   /* Last attach time */
	time_t          shm_dtime;   /* Last detach time */
	time_t          shm_ctime;   /* Last change time */
	pid_t           shm_cpid;    /* PID of creator */
	pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
    // 引用计数, 多少个进程和共享内存进行了关联
	shmatt_t        shm_nattch;  /* 记录了有多少个进程和当前共享内存进行了管联 */
	...
};
```

- **参数**:
  - **shmid**: 要操作的共享内存的ID, 是 shmget() 函数的返回值
  - **cmd**: 要做的操作
    - **IPC_STAT**: 得到当前共享内存的状态
    - **IPC_SET**: 设置共享内存的状态
    - **IPC_RMID**: 标记共享内存要被删除了
  - **buf**:
    - **cmd==IPC_STAT**, 作为传出参数, 会得到共享内存的相关属性信息
    - **cmd==IPC_SET**, 作为传入参, 将用户的自定义属性设置到共享内存中
    - **cmd==IPC_RMID**, buf就没意义了, 这时候buf指定为NULL即可
- **返回值**：函数调用成功返回值大于等于0，调用失败返回-1

### 4.3.2 相关shell命令

使用`ipcs` 添加参数`-m`可以查看系统中共享内存的详细信息

```shell
$ ipcs -m

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态      
0x00000000 425984     oracle     600        524288     2          目标       
0x00000000 327681     oracle     600        524288     2          目标       
0x00000000 458754     oracle     600        524288     2          目标 	
```

使用 `ipcrm` 命令可以标记删除某块共享内存

```shell
# key == shmget的第一个参数
$ ipcrm -M shmkey  

# id == shmget的返回值
$ ipcrm -m shmid
```

### 4.3.3 共享内存状态

```c
// 参数 struct shmid_ds 结构体原型          
struct shmid_ds {
	struct ipc_perm shm_perm;    /* Ownership and permissions */
	size_t          shm_segsz;   /* Size of segment (bytes) */
	time_t          shm_atime;   /* Last attach time */
	time_t          shm_dtime;   /* Last detach time */
	time_t          shm_ctime;   /* Last change time */
	pid_t           shm_cpid;    /* PID of creator */
	pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
    // 引用计数, 多少个进程和共享内存进行了关联
	shmatt_t        shm_nattch;  /* 记录了有多少个进程和当前共享内存进行了管联 */
	...
};
```

通过`shmctl()`我们可以得知，共享内存的信息是存储到一个叫做`struct shmid_ds`的结构体中，其中有一个非常重要的成员叫做`shm_nattch`，在这个成员变量里边记录着当前共享内存关联的进程的个数，一般将其称之为引用计数。当共享内存被标记为删除状态，并且这个引用计数变为0之后共享内存才会被真正的被删除掉。

当共享内存被标记为删除状态之后，共享内存的状态也会发生变化，共享内存内部维护的key从一个正整数变为0，其属性从公共的变为私有的。这里的私有是指只有已经关联成功的进程才允许继续访问共享内存，不再允许新的进程和这块共享内存进行关联了。下图演示了共享内存的状态变化：

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200223112227101.png)](https://subingwen.cn/linux/shm/image-20200223112227101.png)

## 4.4 进程间通信

使用共享内存实现进程间通信的操作流程如下：

```c
1. 调用linux的系统API创建一块共享内存
    - 这块内存不属于任何进程, 默认进程不能对其进行操作
    
2. 准备好进程A, 和进程B, 这两个进程需要和创建的共享内存进行关联
    - 关联操作: 调用linux的 api
    - 关联成功之后, 得到了这块共享内存的起始地址
        
3. 在进程A或者进程B中对共享内存进行读写操作
    - 读内存: printf() 等;
	- 写内存: memcpy() 等;

4. 通信完成, 可以让进程A和B和共享内存解除关联
    - 解除成功, 进程A和B不能再操作共享内存了
    - 共享内存不受进程生命周期的影响的
    
5. 共享内存不在使用之后, 将其删除
    - 调用linux的api函数, 删除之后这块内存被内核回收了
```

> 写共享内存的进程代码:
>

```c
#include <stdio.h>
#include <sys/shm.h>
#include <string.h>

int main()
{
    // 1. 创建共享内存, 大小为4k
    int shmid = shmget(1000, 4096, IPC_CREAT|0664);
    if(shmid == -1)
    {
        perror("shmget error");
        return -1;
    }

    // 2. 当前进程和共享内存关联
    void* ptr = shmat(shmid, NULL, 0);
    if(ptr == (void *) -1)
    {
        perror("shmat error");
        return -1;
    }

    // 3. 写共享内存
    const char* p = "hello, world, 共享内存真香...";
    memcpy(ptr, p, strlen(p)+1);

    // 阻塞程序
    printf("按任意键继续, 删除共享内存\n");
    getchar();

    shmdt(ptr);

    // 删除共享内存
    shmctl(shmid, IPC_RMID, NULL);
    printf("共享内存已经被删除...\n");

    return 0;
}
```

> 读共享内存的进程代码:
>

```c
#include <stdio.h>
#include <sys/shm.h>
#include <string.h>

int main()
{
    // 1. 创建共享内存, 大小为4k
    int shmid = shmget(1000, 0, 0);
    if(shmid == -1)
    {
        perror("shmget error");
        return -1;
    }

    // 2. 当前进程和共享内存关联
    void* ptr = shmat(shmid, NULL, 0);
    if(ptr == (void *) -1)
    {
        perror("shmat error");
        return -1;
    }

    // 3. 读共享内存
    printf("共享内存数据: %s\n", (char*)ptr);

    // 阻塞程序
    printf("按任意键继续, 删除共享内存\n");
    getchar();

    shmdt(ptr);

    // 删除共享内存
    shmctl(shmid, IPC_RMID, NULL);
    printf("共享内存已经被删除...\n");

    return 0;
```

## 4.5 shm和mmap的区别

`共享内存`和`内存映射区`都可以实现进程间通信，下面来分析一下二者的**区别**：

- **实现进程间通信的方式**
  - **shm**: 多个进程只需要一块共享内存就够了，共享内存不属于进程，需要和进程关联才能使用
  - **内存映射区**: 位于每个进程的虚拟地址空间中, 并且需要关联同一个磁盘文件才能实现进程间数据通信
- **效率**:
  - **shm**: 直接对内存操作，效率高
  - **内存映射区**: 需要内存和文件之间的数据同步，效率低
- **生命周期**
  - **内存映射区**：进程退出, 内存映射区也就没有了
  - **shm**：进程退出对共享内存没有影响，调用相关函数/命令/ 关机才能删除共享内存
- **数据的完整性** -> 突发状态下数据能不能被保存下来（比如: 突然断电）
  - **内存映射区**：可以完整的保存数据, 内存映射区数据会同步到磁盘文件
  - **shm**：数据存储在物理内存中, 断电之后系统关闭, 内存数据也就丢失了

# 五、信号 

## 5.1 信号概述

Linux中的信号是一种消息处理机制, 它本质上是一个整数，不同的信号对应不同的值，由于信号的结构简单所以天生不能携带很大的信息量，但是信号在系统中的优先级是非常高的。

在Linux中的很多常规操作中都会有相关的信号产生，先从我们最熟悉的场景说起：

- `通过键盘操作产生了信号`：用户按下Ctrl-C，这个键盘输入产生一个硬件中断，使用这个快捷键会产生信号, 这个信号会杀死对应的某个进程
- `通过shell命令产生了信号`：通过kill命令终止某一个进程，`kill -9 进程PID`
- `通过函数调用产生了信号`：如果CPU当前正在执行这个进程的代码调用，比如函数 `sleep()`，进程收到相关的信号，被迫挂起
- `通过对硬件进行非法访问产生了信号`：正在运行的程序访问了非法内存，发生段错误，进程退出。

信号也可以实现进程间通信，但是信号能传递的数据量很少，不能满足大部分需求，另外信号的优先级很高，并且它对应的处理动作是回调完成的，它会打乱程序原有的处理流程，影响到最终的处理结果。因此非常不建议使用信号进行进程间通信。

### 5.1.1 信号编号

> 通过 `kill -l `命令可以察看系统定义的信号列表:

```shell
# 执行shell命令查看信号
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

下表中详细阐述了信号产生的时机和对应的默认处理动作:

| **编号** | **信号**             | **对应事件**                                                 | **默认动作**               |
| -------- | -------------------- | ------------------------------------------------------------ | -------------------------- |
| 1        | SIGHUP               | 用户退出shell时，由该shell启动的所有进程将收到这个信号       | 终止进程                   |
| 2        | SIGINT               | 当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号 | 终止进程                   |
| 3        | SIGQUIT              | 用户按下<ctrl+\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号 | 终止进程                   |
| 4        | SIGILL               | CPU检测到某进程执行了非法指令                                | 终止进程并产生core文件     |
| 5        | SIGTRAP              | 该信号由断点指令或其他 trap指令产生                          | 终止进程并产生core文件     |
| 6        | SIGABRT              | 调用abort函数时产生该信号                                    | 终止进程并产生core文件     |
| 7        | SIGBUS               | 非法访问内存地址，包括内存对齐出错                           | 终止进程并产生core文件     |
| 8        | SIGFPE               | 在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误 | 终止进程并产生core文件     |
| 9        | SIGKILL              | 无条件终止进程。本信号不能被忽略，处理和阻塞                 | 终止进程，可以杀死任何进程 |
| 10       | SIGUSE1              | 用户定义的信号。即程序员可以在程序中定义并使用该信号         | 终止进程                   |
| 11       | SIGSEGV              | 指示进程进行了无效内存访问(段错误)                           | 终止进程并产生core文件     |
| 12       | SIGUSR2              | 另外一个用户自定义信号，程序员可以在程序中定义并使用该信号   | 终止进程                   |
| 13       | SIGPIPE              | Broken pipe向一个没有读端的管道写数据                        | 终止进程                   |
| 14       | SIGALRM              | 定时器超时，超时的时间 由系统调用alarm设置                   | 终止进程                   |
| 15       | SIGTERM              | 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号 | 终止进程                   |
| 16       | SIGSTKFLT            | Linux早期版本出现的信号，现仍保留向后兼容                    | 终止进程                   |
| 17       | SIGCHLD              | 子进程结束时，父进程会收到这个信号                           | 忽略这个信号               |
| 18       | SIGCONT              | 如果进程已停止，则使其继续运行                               | 继续/忽略                  |
| 19       | SIGSTOP              | 停止进程的执行。信号不能被忽略，处理和阻塞                   | 为终止进程                 |
| 20       | SIGTSTP              | 停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号     | 暂停进程                   |
| 21       | SIGTTIN              | 后台进程读终端控制台                                         | 暂停进程                   |
| 22       | SIGTTOU              | 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生        | 暂停进程                   |
| 23       | SIGURG               | 套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达 | 忽略该信号                 |
| 24       | SIGXCPU              | 进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程 | 终止进程                   |
| 25       | SIGXFSZ              | 超过文件的最大长度设置                                       | 终止进程                   |
| 26       | SIGVTALRM            | 虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间 | 终止进程                   |
| 27       | SGIPROF              | 类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间 | 终止进程                   |
| 28       | SIGWINCH             | 窗口变化大小时发出                                           | 忽略该信号                 |
| 29       | SIGIO                | 此信号向进程指示发出了一个异步IO事件                         | 忽略该信号                 |
| 30       | SIGPWR               | 关机                                                         | 终止进程                   |
| 31       | SIGSYS               | 无效的系统调用                                               | 终止进程并产生core文件     |
| 34~64    | SIGRTMIN ～ SIGRTMAX | LINUX的实时信号，它们没有固定的含义（可以由用户自定义）      | 终止进程                   |

### 5.1.2 查看信号信息

通过Linux提供的 man 文档可以查询所有信号的详细信息:

```shell
# 查看man文档的信号描述
$ man 7 signal
```

在信号描述中介绍了对产生的信号的五种默认处理动作，分别是：

1. `Term`：信号将进程终止
2. `Ign`：信号产生之后默认被忽略了
3. `Core`：信号将进程终止, 并且生成一个core文件(一般用于gdb调试)
4. `Stop`：信号会暂停进程的运行
5. `Cont`：信号会让暂停的进程继续运行

> 关于对信号的介绍有一句非常重要的描述:
>
> ​	The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
>
> ​	9号信号和19号信号不能被 捕捉, 阻塞, 和 忽略
>
> - ​		9号信号: 无条件杀死进程
> - ​		19号信号: 无条件暂停进程

有些信号在不同的平台对应的值是不一样的，对应我们使用PC机来说，需要看中间一列的值：

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200425164709088.png)](https://subingwen.cn/linux/signal/image-20200425164709088.png)

### 5.1.3 信号的状态

Linux中的信号有三种状态，分别为：产生，未决，递达。

1. `产生`：键盘输入, 函数调用, 执行shell命令, 对硬件进行非法访问都会产生信号
2. `未决`：信号产生了, 但是这个信号还没有被处理掉, 这个期间信号的状态称之为未决状态
3. `递达`：信号被处理了(被某个进程处理掉)

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210206135036666.png)](https://subingwen.cn/linux/signal/image-20210206135036666.png)

## 5.2 信号相关函数

Linux中能够产生信号的函数有很多，下面介绍几个常用函数：

### 5.2.1 kill/raise/abort

这三个函数的功能比较类似，可以发送相关的信号给到对应的进程。

- **kill** 发送指定的信号到指定的进程，函数原型如下：

  ```c
  #include <signal.h>
  // 给某一个进程发送一个信号
  int kill(pid_t pid, int sig);
  ```

  - **参数**:
    - **pid**: 进程ID（man 文档里边写的比较详细）
    - **sig**: 要发送的信号

  函数使用举例:

  ```c
  // 自己杀死自己
  kill(getpid(), 9);
  // 子进程杀死自己的父进程
  kill(getppid(), 10);
  ```

- raise：给当前进程发送指定的信号，函数原型如下：

  ```c
  // 给自己发送某一个信号
  #include <signal.h>
  int raise(int sig);	// 参数就是要给当前进程发送的信号
  ```

- abort：给当前进程发送一个固定信号 (SIGABRT)，函数原型如下：

  ```c
  // 这是一个中断函数, 调用这个函数, 发送一个固定信号 (SIGABRT), 杀死当前进程
  #include <stdlib.h>
  void abort(void);
  ```

### 5.2.2 定时器

#### 5.2.2.1 alarm

alarm() 函数只能进行单次定时，定时完成发射出一个信号。

```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```

- 参数: 倒计时seconds秒, 倒计时完成发送一个信号 SIGALRM , 当前进程会收到这个信号，这个信号默认的处理动作是中断当前进程
- 返回值: 大于0表示倒计时还剩多少秒，返回值为0表示倒计时完成, 信号被发出

> 使用这个定时器函数, 检测一下当前计算机1s钟之内能数多少个数
>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main()
{
    // 1. 设置一个定时器, 定时1s
    alarm(1);	// 1s之后会发出一个信号, 这个信号将中断当前进程
    int i = 0;
    while(1)
    {
        printf("%d\n", i++);
    }
    return 0;
}
```

执行上述程序的时候, 计算一下时间

```shell
# 直接通过终端输出
$ time ./a.out
real    0m1.013s		# 实际数数用的总时间
user    0m0.060s		# 用户区代码使用的时间
sys     0m0.324s		# 内核区使用的时间

real = user + sys + 消耗的时间(频率的从用户区到内核区进程切换)


# 不直接写终端, 将数据重定向到磁盘文件中
$ time ./a.out > a.txt
Alarm clock

real    0m1.002s    # 用户实际数数的时间变长了
user    0m0.740s
sys     0m0.236s
```

> 文件IO操作需要进行用户区到内核区的切换，处理方式不同，二者之间切换的频率也不同。也就是说对文件IO操作进行优化是可以提供程序的执行效率的。
>

#### 5.2.2.2 setitimer

**setitimer ()** 函数可以进行周期性定时，每触发一次定时器就会发射出一个信号。

```c
// 这个函数可以实现周期性定时, 每个一段固定的时间, 发出一个特定的定时器信号
#include <sys/time.h>

struct itimerval {
	struct timeval it_interval; /* 时间间隔 */
	struct timeval it_value;    /* 第一次触发定时器的时长 */
};
// 举例: luffy有一个闹钟, 并且使用这个闹钟定时:
// 早晨7点中起床, 第一次闹钟响起时可能起不来, 之后每隔5分钟再响一次
//  - it_value: 当前设置闹钟的时间点 到 明天早晨7点 对应的总秒数
//  - it_interval: 闹钟第一次响过之后, 每隔5分钟响一次

// 这个结构体表示的是一个时间段: tv_sec + tv_usec
struct timeval {
	time_t      tv_sec;         /* 秒 */
	suseconds_t tv_usec;        /* 微妙 */
};

int setitimer(int which, const struct itimerval *new_value, 
              struct itimerval *old_value);
```

- 参数:
  - which: 定时器使用什么样的计时法则, 不同的计时法则发出的信号不同
    - `ITIMER_REAL`: 自然计时法, 最常用, 发出的信号为`SIGALRM`, 一般使用这个宏值，自然计时法时间 = 用户区 + 内核 + 消耗的时间(从进程的用户区到内核区切换使用的总时间)
    - `ITIMER_VIRTUAL`: 只计算程序在用户区运行使用的时间，发射的信号为 `SIGVTALRM`
    - `ITIMER_PROF`: 只计算内核运行使用的时间, 发出的信号为`SIGPROF`
  - new_value: 给定时器设置的定时信息, 传入参数
  - old_value: 上一次给定时器设置的定时信息, 传出参数，如果不需要这个信息, 指定为NULL

## 5.3 信号集

### 5.3.1 阻塞/未决信号集

在PCB中有两个非常重要的信号集。一个称之为“阻塞信号集”，另一个称之为“未决信号集”。这两个信号集体现在内核中就是两张表。但是**操作系统不允许我们直接对这两个信号集进行任何操作，而是需要自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改**。

- **信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间**。
- **信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生**。

信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了 防止信号打断某些敏感的操作。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210206135824272.png)](https://subingwen.cn/linux/signal/image-20210206135824272.png)

阻塞信号集和未决信号集在内核中的结构是相同的，它们都是一个整形数组(被封装过的), 一共 128 字节 （int [32] == 1024 bit），1024个标志位，其中前31个标志位，每一个都对应一个Linux中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。

```shell
# 上图对信号集在内核中存储的状态的描述
# 前31个信号: 1-31 , 对应 1024个标志位的前31个标志位
			信号		标志位(从低地址位 到 高地址位)
		 	  1      ->  	0
			  2             1
			  3             2
			  4             3
			 31            30
```

- 在阻塞信号集中，描述这个信号有没有被阻塞
  - 默认情况下没有信号是被阻塞的, 因此信号对应的标志位的值为 0
  - 如果某个信号被设置为了阻塞状态, 这个信号对应的标志位 被设置为 1
- 在未决信号集中, 描述信号是否处于未决状态
  - 如果这个信号被阻塞了, 不能处理, 这个信号对应的标志位被设置为1
  - 如果这个信号的阻塞被解除了, 未决信号集中的这个信号马上就被处理了, 这个信号对应的标志位值变为0
  - 如果这个信号没有阻塞, 信号产生之后直接被处理, 因此不会在未决信号集中做任何记录

### 5.3.2 信号集函数

因为用户是不能直接操作内核中的阻塞信号集和未决信号集的，必须要调用系统函数，关于阻塞信号集可以通过系统函数进行读写操作，未决信号集只能对其进行读操作。

先来看一下读/写阻塞信号集的函数

```c
#include <signal.h>
// 使用这个函数修改内核中的阻塞信号集
// sigset_t 被封装之后得到的数据类型, 原型:int[32], 里边一共有1024给标志位, 每一个信号对应一个标志位
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

- 参数:
  - how:
    - `SIG_BLOCK`: 将参数 set 集合中的数据追加到阻塞信号集中
    - `SIG_UNBLOCK`: 将参数 set 集合中的信号在阻塞信号集中解除阻塞
    - `SIG_SETMASK`: 使用参 set 结合中的数据覆盖内核的阻塞信号集数据
    - oldset: 通过这个参数将设置之前的阻塞信号集数据传出，如果不需要可以指定为NULL
  - 返回值：函数调用成功返回0，调用失败返回-1

**sigprocmask()** 函数有一个 sigset_t 类型的参数，对这种类型的数据进行初始化需要调用一些相关的操作函数：

```c
#include <signal.h>
// 如果在程序中读写 sigset_t 类型的变量
// 阻塞信号集和未决信号集都存储在 sigset_t 类型的变量中, 这个变量对应一块内存
// 阻塞信号集和未决信号集, 对应的内存中有1024bit = 128字节

// 将set集合中所有的标志位设置为0
int sigemptyset(sigset_t *set);
// 将set集合中所有的标志位设置为1
int sigfillset(sigset_t *set);
// 将set集合中某一个信号(signum)对应的标志位设置为1
int sigaddset(sigset_t *set, int signum);
// 将set集合中某一个信号(signum)对应的标志位设置为0
int sigdelset(sigset_t *set, int signum);
// 判断某个信号在集合中对应的标志位到底是0还是1, 如果是0返回0, 如果是1返回1
int sigismember(const sigset_t *set, int signum);
```

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210206142122901.png)](https://subingwen.cn/linux/signal/image-20210206142122901.png)

未决信号集不需要程序猿修改, 如果设置了某个信号阻塞, 当这个信号产生之后, 内核会将这个信号的未决状态记录到未决信号集中，当阻塞的信号被解除阻塞, 未决信号集中的信号随之被处理, 内核再次修改未决信号集将该信号的状态修改为递达状态（标志位置0）。因此，写未决信号集的动作都是内核做的，这是一个读未决信号集的操作函数：

```c
#include <signal.h>
// 这个函数的参数是传出参数, 传出的内核未决信号集的拷贝
// 读一下这个集合就指定哪个信号是未决状态
int sigpending(sigset_t *set);
```

下面举一个简单的例子，演示一下信号集操作函数的使用：

```c
需求: 
在阻塞信号集中设置某些信号阻塞, 通过一些操作产生这些信号, 然后读未决信号集, 最后再解除这些信号的阻塞
假设阻塞这些信号: 
  - 2号信号: SIGINT: ctrl+c
  - 3号信号: SIGQUIT: ctrl+\
  - 9号信号: SIGKILL: 通过shell命令给进程发送这个信号 kill -9 PID
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>

int main()
{
    // 1. 初始化信号集
    sigset_t myset;
    sigemptyset(&myset);
    // 设置阻塞的信号
    sigaddset(&myset, SIGINT);  // 2
    sigaddset(&myset, SIGQUIT); // 3
    sigaddset(&myset, SIGKILL); // 9 测试不能被阻塞

    // 2. 将初始化的信号集中的数据设置给内核
    sigset_t old;
    sigprocmask(SIG_BLOCK, &myset, &old);

    // 3. 让进程一直运行, 在当前进程中产生对应的信号
    int i = 0;
    while(1)
    {
        // 4. 读内核的未决信号集
        sigset_t curset;
        sigpending(&curset);
        // 遍历这个信号集
        for(int i=1; i<32; ++i)
        {
            int ret = sigismember(&curset, i);
            printf("%d", ret);
        }
        printf("\n");
        sleep(1);
        i++;
        if(i==10)
        {
            // 解除阻塞, 重新设置阻塞信号集
            //sigprocmask(SIG_UNBLOCK, &myset, NULL);
            sigprocmask(SIG_SETMASK, &old, NULL);
        }
    }
    return 0;
}
```

> 通过测试最终得到结论：==程序中对 9 号信号的阻塞是无效的，因为它无法被阻塞==。

最后通过一张图总结一下这些信号集操作函数之间的关系:

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20210206181522522.png)](https://subingwen.cn/linux/signal/image-20210206181522522.png)

## 5.4 信号捕捉

Linux中的每个信号产生之后都会有对应的默认处理行为，如果想要忽略这个信号或者修改某些信号的默认行为就需要在程序中捕捉该信号。程序中进行信号捕捉可以看做是一个注册的动作，提前告诉应用程序信号产生之后做什么样的处理，当进程中对应的信号产生了，这个处理动作也就被调用了。

### 5.4.1 signal

使用 signal() 函数可以捕捉进程中产生的信号，并且修改捕捉到的函数的行为，这个信号的自定义处理动作是一个回调函数，内核通过 signal() 得到这个回调函数的地址，在信号产生之后该函数会被内核调用。

```c
#include <signal.h>
// 在程序中什么时候产生信号, 程序猿是不知道的, 因此不能在信号产生之后再去处理
// 在信号产生之前, 提供一个注册函数, 用来捕捉信号
//	  - 假设在将来这个信号产生了, 就委托内核进行捕捉, 这个信号的默认动作就不能被执行
//	  - 执行什么样的处理动作 ==> 在signal函数中指定的处理动作
//	  - 如果这个信号不产生, 回调函数永远不会被调用
sighandler_t signal(int signum, sighandler_t handler);
```

- 参数:

  - signum: 需要捕捉的信号

  - handler: 信号捕捉到之后的处理动作, 这是一个函数指针, 函数原型

    ```c
    typedef void (*sighandler_t)(int);
    ```

    **这个回调函数是需要程序猿写的, 但是程序猿不调用, 由内核调用，内核调用回调函数的时候, 会给它传递一个实参，这个实参的值就是捕捉的那个信号值。**

下面的测试程序中使用 signal() 函数来捕捉定时器产生的信号 **SIGALRM**：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/time.h>
#include <signal.h>

// 定时器信号的处理动作
void doing(int arg)
{
    printf("当前捕捉到的信号是: %d\n", arg);
    // 打印当前的时间
}

int main()
{
    // 注册要捕捉哪一个信号, 执行什么样的处理动作
    signal(SIGALRM, doing);
    // 1. 调用定时器函数设置定时器函数
    struct itimerval newact;
    // 3s之后发出第一个定时器信号, 之后每隔1s发出一个定时器信号
    newact.it_value.tv_sec = 3;
    newact.it_value.tv_usec = 0;
    newact.it_interval.tv_sec = 1;
    newact.it_interval.tv_usec = 0;
    // 这个函数也不是阻塞函数, 函数调用成功, 倒计时开始
    // 倒计时过程中程序是继续运行的
    setitimer(ITIMER_REAL, &newact, NULL);

    // 编写一个业务处理, 阻止当前进程自己结束, 让当前进程被发出的信号杀死
    while(1)
    {
        sleep(1000000);
    }

    return 0;
}
```

### 5.4.2 sigaction

sigaction() 函数和 signal() 函数的功能是一样的，用于捕捉进程中产生的信号，并将用户自定义的信号行为函数（回调函数）注册给内核，内核在信号产生之后调用这个处理动作。sigaction() 可以看做是 signal() 函数是加强版，函数参数更多更复杂，函数功能也更强一些。函数原型如下：

```c
#include <signal.h>
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

- **参数**:
  - **signum**: 要捕捉的信号
  - **act**: 捕捉到信号之后的处理动作
  - **oldact**: 上一次调用该函数进行信号捕捉设置的信号处理动作, 该参数一般指定为NULL
- **返回值**：函数调用成功返回0，失败返回-1

该函数的参数是一个结构体类型，结构体原型如下：

```c
struct sigaction {
	void     (*sa_handler)(int);    // 指向一个函数(回调函数)
	void     (*sa_sigaction)(int, siginfo_t *, void *);
	sigset_t   sa_mask;             // 初始化为空即可, 处理函数执行期间不屏蔽任何信号
	int        sa_flags;	        // 0
	void     (*sa_restorer)(void);  //不用
};
```

**结构体成员**介绍：

- **sa_handler**: 函数指针，指向的函数就是捕捉到的信号的处理动作
- **sa_sigaction**: 函数指针，指向的函数就是捕捉到的信号的处理动作
- **sa_mask**: 在信号处理函数执行期间, 临时屏蔽某些信号, 将要屏蔽的信号设置到集合中即可
  - 当前处理函数执行完毕, 临时屏蔽自动解除
  - 假设在这个集合中不屏蔽任何信号, 默认也会屏蔽一个（捕捉的信号是谁, 就临时屏蔽谁）
- **sa_flags**：使用哪个函数指针指向的函数处理捕捉到的信号
  - `0`：使用 `sa_handler `(一般情况下使用这个)
  - `SA_SIGINFO`：使用 sa_sigaction (使用信号传递数据==进程间通信)
- **sa_restorer**: 被废弃的成员

示例代码，通过sigaction()捕捉阻塞信号集中解除阻塞的信号，如果捕捉多个信号，可以给不同的信号添加不同的处理动作，代码中的处理动作只有一个：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>

// 信号的处理动作
void callback(int num)
{
    printf("当前捕捉的信号: %d\n", num);
}

int main()
{
    // 1. 初始化信号集
    sigset_t myset;
    sigemptyset(&myset);
    // 设置阻塞的信号
    sigaddset(&myset, SIGINT);  // 2
    sigaddset(&myset, SIGQUIT); // 3
    sigaddset(&myset, SIGKILL); // 9 测试不能被阻塞

    // 当阻塞的信号被解除阻塞, 该信号就可以被捕捉到了
    // 如果信号被捕捉到之后, 马上就被处理掉了 --> 递达状态
    struct sigaction act;
    act.sa_handler = callback;
    act.sa_flags = 0;
    sigemptyset(&act.sa_mask);
    sigaction(SIGINT, &act, NULL);
    // 和sigint的处理动作相同
    sigaction(SIGQUIT, &act, NULL);
    sigaction(SIGKILL, &act, NULL);

    // 2. 将初始化的信号集中的数据设置给内核
    sigset_t old;
    sigprocmask(SIG_BLOCK, &myset, &old);

    // 3. 让进程一直运行, 在当前进程中产生对应的信号
    int i = 0;
    while(1)
    {
        // 4. 读内核的未决信号集
        sigset_t curset;
        sigpending(&curset);
        // 遍历这个信号集
        for(int i=1; i<32; ++i)
        {
            int ret = sigismember(&curset, i);
            printf("%d", ret);
        }
        printf("\n");
        sleep(1);
        i++;
        if(i==10)
        {
            // 解除阻塞, 重新设置阻塞信号集
            //sigprocmask(SIG_UNBLOCK, &myset, NULL);
            sigprocmask(SIG_SETMASK, &old, NULL);
        }
    }
    return 0;
}
```

> 通过测试最终得到结论：==程序中对 9 号信号的捕捉是无效的，因为它无法被捕捉==。

## 5.5 SIGCHLD 信号

当子进程退出、暂停、从暂停回复运行的时候，在子进程中会产生一个SIGCHLD信号，并将其发送给父进程，但是父进程收到这个信号之后默认就忽略了。我们可以在父进程中对这个信号加以利用，基于这个信号来回收子进程的资源，因此需要在父进程中捕捉子进程发送过来的这个信号。

下面是基于信号回收子进程资源的示例代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
#include <signal.h>

// 回收子进程处理函数
void recycle(int num)
{
    printf("捕捉到的信号是: %d\n", num);
    // 子进程的资源回收, 非阻塞
    // SIGCHLD信号17号信号, 1-31号信号不支持排队
    // 如果这些信号同时产生多个, 最终处理的时候只处理一次
    // 假设多个子进程同时退出, 父进程同时收到了多个sigchld信号
    // 父进程只会处理一次这个信号, 因此当前函数被调用了一次, waitpid被调用一次
    // 相当于只回收了一个子进程, 但是是同时死了多个子进程, 因此就出现了僵尸进程
    // 解决方案: 循环回收即可
    while(1)
    {
        // 如果是阻塞回收, 就回不到另外一个处理逻辑上去了
        pid_t pid = waitpid(-1, NULL, WNOHANG);
        if(pid > 0)
        {
            printf("child died, pid = %d\n", pid);
        }
        else if(pid == 0)
        {
            // 没有死亡的子进程, 直接退出当前循环
            break;
        }
        else if(pid == -1)
        {
            printf("所有子进程都回收完毕了, 拜拜...\n");
            break;
        }
    }
}


int main()
{
    // 设置sigchld信号阻塞
    sigset_t myset;
    sigemptyset(&myset);
    sigaddset(&myset, SIGCHLD);
    sigprocmask(SIG_BLOCK, &myset, NULL);

    // 循环创建多个子进程 - 20
    pid_t pid;
    for(int i=0; i<20; ++i)
    {
        pid = fork();
        if(pid == 0)
        {
            break;
        }
    }

    if(pid == 0)
    {
        printf("我是子进程, pid = %d\n", getpid());
    }
    else if(pid > 0)
    {
        printf("我是父进程, pid = %d\n", getpid());
        // 注册信号捕捉, 捕捉sigchld
        struct sigaction act;
        act.sa_flags  =0;
        act.sa_handler = recycle;
        sigemptyset(&act.sa_mask);
        // 注册信号捕捉, 委托内核处理将来产生的信号
        // 当信号产生之后, 当前进程优先处理信号, 之前的处理动作会暂停
        // 信号处理完毕之后, 回到原来的暂停的位置继续运行
        sigaction(SIGCHLD, &act, NULL);

        // 解除sigcld信号的阻塞
        // 信号被阻塞之后,就捕捉不到了, 解除阻塞之后才能捕捉到这个信号
        sigprocmask(SIG_UNBLOCK, &myset, NULL);

        // 父进程执行其他业务逻辑就可以了
        // 默认父进程执行这个while循环, 但是信号产生了, 这个执行逻辑或强迫暂停
        // 	父进程去处理信号的处理函数
        while(1)
        {
            sleep(100);
        }
    }
    return 0;
}
```

# 六、守护进程

**守护进程**（**Daemon Process**），也就是通常说的 **Daemon 进程**（**精灵进程**），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。

## 6.1 进程组

多个进程的集合就是进程组, 这个组中必须有一个组长, 组长就是进程组中的第一个进程，组长以外的都是普通的成员，每个进程组都有一个唯一的组ID，进程组的ID和组长的PID是一样的。

进程组中的成员是可以转移的，如果当前进程组中的成员被转移到了其他的组，或者进制中的所有进程都退出了，那么这个进程组也就不存在了。如果进程组中组长死了, 但是当前进程组中有其他进程，这个进程组还是继续存在的。下面介绍几个常用的进程组函数：

> 得到当前进程所在的进程组的组ID

```c
pid_t getpgrp(void);
```

> 获取指定的进程所在的进程组的组ID，参数 pid 就是指定的进程

```c
pid_t getpgid(pid_t pid);
```

将某个进程移动到其他进程组中或者创建新的进程组

```c
int setpgid(pid_t pid, pid_t pgid);
```

- **参数**:
  - **pid**: 某个进程的进程ID
  - **pgid**: 某个进程组的组ID
    - 如果pgid对应的进程组存在，pid对应的进程会移动到这个组中, pid != pgid
    - 如果pgid对应的进程组不存在，会创建一个新的进程组, 因此要求 pid == pgid, 当前进程就是组长了
- **返回值**：函数调用成功返回0，失败返回-1

## 6.2 会话

**会话**(**session**)是由一个或多个进程组组成的，一个会话可以对应一个控制终端, 也可以没有。一个普通的进程可以调用 `setsid()` 函数使自己成为新 session 的领头进程（会长），并且这个 session 领头进程还会被放入到一个新的进程组中。先来看一下`setsid()`函数的原型:

```c
#include <unistd.h>

// 获取某个进程所属的会话ID
pid_t getsid(pid_t pid);

// 将某个进程变成会话 =>> 得到一个守护进程
// 使用哪个进程调用这个函数, 这个进程就会变成一个会话
pid_t setsid(void);
```

> 使用这个函数的注意事项:
>
> 1. 调用这个函数的进程不能是组长进程, 如果是该函数调用失败，如果保证这个函数能调用成功呢?
>    - 先fork()创建子进程, 终止父进程, 让子进程调用这个函数
> 2. 如果调用这个函数的进程不是进程组长, 会话创建成功
>    - 这个进程会变成当前会话中的第一个进程，同时也会变成新的进程组的组长
>    - 该函数调用成功之后, 当前进程就脱离了控制终端，因此不会阻塞终端

## 6.3 创建守护进程

如果要创建一个守护进程，标准步骤如下，部分操作可以根据实际需求进行取舍：

1. 创建子进程, 让父进程退出

   - 因为父进程有可能是组长进程，不符合条件，也没有什么利用价值，退出即可
   - 子进程没有任何职务, 目的是让子进程最终变成一个会话, 最终就会得到守护进程

2. 通过子进程创建新的会话，调用函数 setsid()，脱离控制终端, 变成守护进程

3. 改变当前进程的工作目录 (可选项, 不是必须要做的)

   - 某些文件系统可以被卸载, 比如: U盘, 移动硬盘，进程如果在这些目录中运行，运行期间这些设备被卸载了，运行的进程也就不能正常工作了。

   - 修改当前进程的工作目录需要调用函数 `chdir()`

     ```c
     int chdir(const char *path);
     ```

4. 重新设置文件的掩码 (可选项, 不是必须要做的)

   - 掩码: umask, 在创建新文件的时候需要和这个掩码进行运算, 去掉文件的某些权限

   - 设置掩码需要使用函数 `umask()`

     ```c
     mode_t umask(mode_t mask);
     ```

5. 关闭/重定向文件描述符 (不做也可以, 但是建议做一下)

   - 启动一个进程, 文件描述符表中默认有三个被打开了, 对应的都是当前的终端文件

   - 因为进程通过调用 setsid() 已经脱离了当前终端, 因此关联的文件描述符也就没用了, 可以关闭

     ```c
     close(STDIN_FILENO);close(STDOUT_FILENO);close(STDERR_FILENO);
     ```

   - 重定向文件描述符(和关闭二选一): 改变文件描述符关联的默认文件, 让他们指向一个特殊的文件`/dev/null`，只要把数据扔到这个特殊的设备文件中, 数据被被销毁了

     ```c
     int fd = open("/dev/null", O_RDWR);
     // 重定向之后, 这三个文件描述符就和当前终端没有任何关系了
     dup2(fd, STDIN_FILENO);
     dup2(fd, STDOUT_FILENO);
     dup2(fd, STDERR_FILENO);
     ```

6. 根据实际需求在守护进程中执行某些特定的操作

## 6.4 守护进程的应用

写一个守护进程, 每隔2s获取一次系统时间, 并将得到的时间写入到磁盘文件中。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/time.h>
#include <time.h>

// 信号的处理动作
void writeFile(int num)
{
    // 得到系统时间
    time_t seconds = time(NULL);
    // 时间转换, 总秒数 -> 可以识别的时间字符串
    struct tm* loc = localtime(&seconds);
    // sprintf();
    char* curtime = asctime(loc); // 自带换行
    // 打开一个文件, 如果文件不存在, 就创建, 文件需要有追加属性
    // ./对应的是哪个目录? /home/robin
    // 0664 & ~022
    int fd = open("./time+++++++.log", O_WRONLY|O_CREAT|O_APPEND, 0664);
    write(fd, curtime, strlen(curtime));
    close(fd);
}

int main()
{
    // 1. 创建子进程, 杀死父进程
    pid_t pid = fork();
    if(pid > 0)
    {
        // 父进程
        exit(0); // kill(getpid(), 9); raise(9); abort();
    }

    // 2. 子进程, 将其变成会话, 脱离当前终端
    setsid();

    // 3. 修改进程的工作目录, 修改到一个不能被修改和删除的目录中 /home/robin
    chdir("/home/robin");

    // 4. 设置掩码, 在进程中创建文件的时候这个掩码就起作用了
    umask(022);

    // 5. 重定向和终端关联的文件描述符 -> /dev/null
    int fd = open("/dev/null", O_RDWR);
    dup2(fd, STDIN_FILENO);
    dup2(fd, STDOUT_FILENO);
    dup2(fd, STDERR_FILENO);

    // 5. 委托内核捕捉并处理将来发生的信号-SIGALRM(14)
    struct sigaction act;
    act.sa_flags = 0;
    act.sa_handler = writeFile;
    sigemptyset(&act.sa_mask);
    sigaction(SIGALRM, &act, NULL);

    // 6. 设置定时器
    struct itimerval val;
    val.it_value.tv_sec = 2;
    val.it_value.tv_usec = 0;
    val.it_interval.tv_sec = 2;
    val.it_interval.tv_usec = 0;
    setitimer(ITIMER_REAL, &val, NULL);

    while(1)
    {
        sleep(100);
    }

    return 0;
}
```

# 七、线程/多线程

## 7.1 线程概述

**线程**是**轻量级的进程**（**LWP：light weight process**），在Linux环境下线程的本质仍是进程。在计算机上运行的程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行。操作系统会以进程为单位，分配系统资源，可以这样理解，`进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。`

先从概念上了解一下**线程**和**进程**之间的区别：

- **进程有自己独立的地址空间, 多个线程共用同一个地址空间**
  - 线程更加节省系统资源, 效率不仅可以保持的, 而且能够更高
  - 在一个地址空间中多个线程独享: 每个线程都有属于自己的栈区, 寄存器(内核中管理的)
  - 在一个地址空间中多个线程共享: 代码段, 堆区, 全局数据区, 打开的文件(文件描述符表)都是线程共享的
- **线程是程序的最小执行单位**, **进程是操作系统中最小的资源分配单位**
  - 每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片
  - 一个地址空间中可以划分出多个线程, 在有效的资源基础上, 能够抢更多的CPU时间片

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/1048430-20170710134655212-558296442.png)](https://subingwen.cn/linux/thread/1048430-20170710134655212-558296442.png)

- **CPU的调度和切换**: 线程的上下文切换比进程要快的多

  **上下文切换**：进程/线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存, 下次切换回这个任务的时候, 加载这个状态继续运行，`任务从保存到再次加载这个过程就是一次上下文切换`。

- **线程更加廉价, 启动速度更快, 退出也快, 对系统资源的冲击小**。

在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好，如何控制线程的个数呢？

1. 文件IO操作：文件IO对CPU是使用率不高, 因此可以分时复用CPU时间片, 线程的个数 = 2 * CPU核心数 (效率最高)
2. 处理复杂的算法(主要是CPU进行运算, 压力大)，线程的个数 = CPU的核心数 (效率最高)

## 7.2 创建线程

### 7.2.1 线程函数

每一个线程都有一个唯一的线程ID，ID类型为`pthread_t`，这个ID是一个无符号长整形数，如果想要得到当前线程的线程ID，可以调用如下函数：

```c
pthread_t pthread_self(void);	// 返回当前线程的线程ID
```

在一个进程中调用线程创建函数，就可得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
// Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a
```

- **参数**:
  - **thread**: 传出参数，是无符号长整形数，线程创建成功, 会将线程ID写入到这个指针指向的内存中
  - **attr**: 线程的属性, 一般情况下使用默认属性即可, 写NULL
  - **start_routine**: 函数指针，创建出的子线程的处理动作，也就是该函数在子线程中执行。
  - **arg**: 作为实参传递到 start_routine 指针指向的函数内部
- **返回值**：线程创建成功返回0，创建失败返回对应的错误号

### 7.2.2 创建线程

下面是创建线程的示例代码，在创建过程中一定要保证编写的线程函数与规定的函数指针类型一致：`void *(*start_routine) (void *)`:

```c
// pthread_create.c 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }
    
    // 休息, 休息一会儿...
    // sleep(1);
    
    return 0;
}
```

编译测试程序，会看到如下错误信息：

```shell
$ gcc pthread_create.c 
/tmp/cctkubA6.o: In function `main':
pthread_create.c:(.text+0x7f): undefined reference to `pthread_create'
collect2: error: ld returned 1 exit status
```

`错误原因是因为编译器链接不到线程库文件（动态库），需要在编译的时候通过参数指定出来`，动态库名为 `libpthread.so`需要使用的参数为 `-l`，根据规则掐头去尾最终形态应该写成：`-lpthread（参数和参数值中间可以有空格）`。正确的编译命令为：

```shell
# pthread_create 函数的定义在某一个库中, 编译的时候需要加库名 pthread
$ gcc pthread_create.c -lpthread
$ ./a.out 
子线程创建成功, 线程ID: 139712560109312
我是主线程, 线程ID: 139712568477440
i = 0
i = 1
i = 2
```

> 在打印的日志输出中为什么子线程处理函数没有执行完毕呢（只看到了子线程的部分日志输出）？
> 主线程一直在运行, 执行期间创建出了子线程，说明主线程有CPU时间片, 在这个时间片内将代码执行完毕了, 主线程就退出了。`子线程被创建出来之后需要抢cpu时间片, 抢不到就不能运行，如果主线程退出了, 虚拟地址空间就被释放了, 子线程就一并被销毁了。但是如果某一个子线程退出了, 主线程仍在运行, 虚拟地址空间依旧存在。`
>
> 得到的结论：在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关。
>
> 目前的解决方案: 让子线程执行完毕, 主线程再退出, 可以在主线程中添加挂起函数 `sleep();`

## 7.3 线程退出

在编写多线程程序的时候，如果想要让线程退出，但是不会导致虚拟地址空间的释放（针对于主线程），我们就可以调用线程库中的线程退出函数，`只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。`

```c
#include <pthread.h>
void pthread_exit(void *retval);
```

- 参数: 线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为NULL

> 下面是线程退出的示例代码，可以在任意线程的需要的位置调用该函数：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    sleep(1);
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        if(i==6)
        {
            pthread_exit(NULL);	// 直接退出子线程
        } 
        printf("child == i: = %d\n", i);
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }

    // 主线程调用退出函数退出, 地址空间不会被释放
    pthread_exit(NULL);
    
    return 0;
}
```

## 7.4 线程回收

### 7.4.1 线程函数

线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做`pthread_join()`，这个函数是一个阻塞函数，`如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。`

另外通过线程回收函数还可以获取到子线程退出时传递出来的数据，函数原型如下：

```c
#include <pthread.h>
// 这是一个阻塞函数, 子线程在运行这个函数就阻塞
// 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()
int pthread_join(pthread_t thread, void **retval);
```

- **参数**:
  - **thread**: 要被回收的子线程的线程ID
  - **retval**: 二级指针, 指向一级指针的地址, 是一个传出参数, 这个地址中存储了pthread_exit() 传递出的数据，如果不需要这个参数，可以指定为NULL
- **返回值**：线程回收成功返回0，回收失败返回错误号。

### 7.4.2 回收子线程数据

在子线程退出的时候可以使用`pthread_exit()`的参数将数据传出，在回收这个子线程的时候可以通过`phread_join()`的第二个参数来接收子线程传递出的数据。接收数据有很多种处理方式，下面来列举几种：

#### 7.4.2.1 使用子线程栈

通过函数`pthread_exit(void *retval);`可以得知，子线程退出的时候，需要将数据记录到一块内存中，通过参数传出的是存储数据的内存的地址，而不是具体数据，由因为参数是`void*`类型，所有这个万能指针可以指向任意类型的内存地址。先来看第一种方式，将子线程退出数据保存在子线程自己的栈区：

```c
// pthread_join.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 定义结构
struct Persion
{
    int id;
    char name[36];
    int age;
};

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            struct Persion p;
            p.age  =12;
            strcpy(p.name, "tom");
            p.id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(&p);
        }
    }
    return NULL;	// 代码执行不到这个位置就退出了
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }

    // 阻塞等待子线程退出
    void* ptr = NULL;
    // ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
    // 这个内存地址就是pthread_exit() 参数指向的内存
    pthread_join(tid, &ptr);
    // 打印信息
    struct Persion* pp = (struct Persion*)ptr;
    printf("子线程返回数据: name: %s, age: %d, id: %d\n", pp->name, pp->age, pp->id);
    printf("子线程资源被成功回收...\n");
    
    return 0;
}
```

编译并执行测试程序:

```shell
# 编译代码
$ gcc pthread_join.c -lpthread
# 执行程序
$ ./a.out 
子线程创建成功, 线程ID: 140652794640128
我是主线程, 线程ID: 140652803008256
i = 0
i = 1
i = 2
我是子线程, 线程ID: 140652794640128
child == i: = 0
child == i: = 1
child == i: = 2
child == i: = 3
child == i: = 4
child == i: = 5
child == i: = 6
子线程返回数据: name: , age: 0, id: 0
子线程资源被成功回收...
```

> 通过打印的日志可以发现，在主线程中没有没有得到子线程返回的数据信息，具体原因是这样的：
>
> **==如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。==**

#### 7.4.2.2 使用全局变量

位于同一虚拟地址空间中的线程，虽然`不能共享栈区数据，但是可以共享全局数据区和堆区数据`，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。在下面的例子中将数据存储到了全局变量中：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 定义结构
struct Persion
{
    int id;
    char name[36];
    int age;
};

struct Persion p;	// 定义全局变量

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            // 使用全局变量
            p.age  =12;
            strcpy(p.name, "tom");
            p.id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(&p);
        }
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }

    // 阻塞等待子线程退出
    void* ptr = NULL;
    // ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
    // 这个内存地址就是pthread_exit() 参数指向的内存
    pthread_join(tid, &ptr);
    // 打印信息
    struct Persion* pp = (struct Persion*)ptr;
    printf("name: %s, age: %d, id: %d\n", pp->name, pp->age, pp->id);
    printf("子线程资源被成功回收...\n");
    
    return 0;
}
```

#### 7.4.2.3 使用主线程栈

虽然每个线程都有属于自己的栈区空间，但是`位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的`。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区内存中：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 定义结构
struct Persion
{
    int id;
    char name[36];
    int age;
};


// 子线程的处理代码
void* working(void* arg)
{
    struct Persion* p = (struct Persion*)arg;
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
        if(i == 6)
        {
            // 使用主线程的栈内存
            p->age  =12;
            strcpy(p->name, "tom");
            p->id = 100;
            // 该函数的参数将这个地址传递给了主线程的pthread_join()
            pthread_exit(p);
        }
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;

    struct Persion p;
    // 主线程的栈内存传递给子线程
    pthread_create(&tid, NULL, working, &p);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }

    // 阻塞等待子线程退出
    void* ptr = NULL;
    // ptr是一个传出参数, 在函数内部让这个指针指向一块有效内存
    // 这个内存地址就是pthread_exit() 参数指向的内存
    pthread_join(tid, &ptr);
    // 打印信息
    printf("name: %s, age: %d, id: %d\n", p.name, p.age, p.id);
    printf("子线程资源被成功回收...\n");
    
    return 0;
}
```

在上面的程序中，调用`pthread_create()`创建子线程，并将主线程中栈空间变量`p`的地址传递到了子线程中，在子线程中将要传递出的数据写入到了这块内存中。也就是说在程序的`main()`函数中，通过指针变量`ptr`或者通过结构体变量`p`都可以读出子线程传出的数据。

## 7.5 线程分离

在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用`pthread_join()`只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。

在线程库函数中为我们提供了线程分离函数`pthread_detach()`，调用这个函数之后指定的`子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了`。线程分离之后在主线程中使用`pthread_join()`就回收不到子线程资源了。

```c
#include <pthread.h>
// 参数就子线程的线程ID, 主线程就可以和这个子线程分离了
int pthread_detach(pthread_t thread);
```

下面的代码中，在主线程中创建子线程，并调用线程分离函数，实现了主线程和子线程的分离：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf("child == i: = %d\n", i);
    }
    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }

    // 设置子线程和主线程分离
    pthread_detach(tid);

    // 让主线程自己退出即可
    pthread_exit(NULL);
    
    return 0;
}
```

## 7.6 其他线程函数

### 7.6.1 线程取消

线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：

1. 在线程A中调用线程取消函数`pthread_cancel`，指定杀死线程B，这时候线程B是死不了的
2. 在线程B中进程一次系统调用（从用户区切换到内核区），否则线程B可以一直运行。

这其实和`七步断肠散`、`含笑半步癫`的功效是一样的，吃了毒药不动或者不笑也没啥事儿

​																							[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/015CBAA8.png)	](https://subingwen.cn/linux/thread/015CBAA8.png)		

```c
#include <pthread.h>
// 参数是子线程的线程ID
int pthread_cancel(pthread_t thread);
```

- 参数：要杀死的线程的线程ID
- 返回值：函数调用成功返回0，调用失败返回非0错误号。

在下面的示例代码中，主线程调用线程取消函数，只要在子线程中进行了系统调用，当子线程执行到这个位置就挂掉了。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 子线程的处理代码
void* working(void* arg)
{
    int j=0;
    for(int i=0; i<9; ++i)
    {
        j++;
    }
    // 这个函数会调用系统函数, 因此这是个间接的系统调用
    printf("我是子线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<9; ++i)
    {
        printf(" child i: %d\n", i);
    }

    return NULL;
}

int main()
{
    // 1. 创建一个子线程
    pthread_t tid;
    pthread_create(&tid, NULL, working, NULL);

    printf("子线程创建成功, 线程ID: %ld\n", tid);
    // 2. 子线程不会执行下边的代码, 主线程执行
    printf("我是主线程, 线程ID: %ld\n", pthread_self());
    for(int i=0; i<3; ++i)
    {
        printf("i = %d\n", i);
    }

    // 杀死子线程, 如果子线程中做系统调用, 子线程就结束了
    pthread_cancel(tid);

    // 让主线程自己退出即可
    pthread_exit(NULL);
    
    return 0;
}
```

> 关于系统调用有两种方式：
>
> 1. 直接调用Linux系统函数
> 2. 调用标准C库函数，为了实现某些功能，在Linux平台下标准C库函数会调用相关的系统函数

### 7.6.2 线程ID比较

在Linux中线程ID本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的ID，但是线程库是可以跨平台使用的，在某些平台上 `pthread_t`可能不是一个单纯的整形，这中情况下比较两个线程的ID必须要使用比较函数，函数原型如下：

```c
#include <pthread.h>
int pthread_equal(pthread_t t1, pthread_t t2);
```

- 参数：t1 和 t2 是要比较的线程的线程ID
- 返回值：如果两个线程ID相等返回非0值，如果不相等返回0

## 7.7 C++线程类

C++11之前，C++语言没有对并发编程提供语言级别的支持，这使得我们在编写可移植的并发程序时，存在诸多的不便。现在C++11中增加了线程以及线程相关的类，很方便地支持了并发编程，使得编写的多线程程序的可移植性得到了很大的提高。

C++11中提供的线程类叫做`std::thread`，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。我们首先来了解一下这个类提供的一些常用API：

### 7.7.1 构造函数

```c++
// ①
thread() noexcept;
// ②
thread( thread&& other ) noexcept;
// ③
template< class Function, class... Args >
explicit thread( Function&& f, Args&&... args );
// ④
thread( const thread& ) = delete;
```

- 构造函数①：默认构造函，构造一个线程对象，在这个线程中不执行任何处理动作
- 构造函数②：移动构造函数，将 `other `的线程所有权转移给新的`thread` 对象。之后 `other` 不再表示执行线程。
- 构造函数③：创建线程对象，并在该线程中执行函数`f`中的业务逻辑，`args`是要传递给函数`f`的参数
  - 任务函数`f`的可选类型有很多，具体如下：
    - `普通函数`，`类成员函数`，`匿名函数`，`仿函数`（这些都是可调用对象类型）
    - 可以是可调用对象包装器类型，也可以是使用绑定器绑定之后得到的类型（仿函数）
- 构造函数④：使用`=delete`显示删除拷贝构造, 不允许线程对象之间的拷贝

### 7.7.2 公共成员函数

#### 7.7.2.1 get_id()

应用程序启动之后默认只有一个线程，这个线程一般称之为`主线程或父线程`，通过线程类创建出的线程一般称之为`子线程`，每个被创建出的线程实例都对应一个线程ID，这个ID是唯一的，可以通过这个ID来区分和识别各个已经存在的线程实例，这个获取线程ID的函数叫做`get_id()`，函数原型如下：

```c++
std::thread::id get_id() const noexcept;
```

示例程序如下：

```c++
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void func(int num, string str)
{
    for (int i = 0; i < 10; ++i)
    {
        cout << "子线程: i = " << i << "num: " 
             << num << ", str: " << str << endl;
    }
}

void func1()
{
    for (int i = 0; i < 10; ++i)
    {
        cout << "子线程: i = " << i << endl;
    }
}

int main()
{
    cout << "主线程的线程ID: " << this_thread::get_id() << endl;
    thread t(func, 520, "i love you");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
}
```

- **thread t(func, 520, "i love you");**：创建了子线程对象 **t**，**func()** 函数会在这个子线程中运行
  - `func()`是一个回调函数，线程启动之后就会执行这个任务函数，程序猿只需要实现即可
  - `func()`的参数是通过`thread`的参数进行传递的，`520`,`i love you`都是调用`func()`需要的实参
  - 线程类的构造函数③是一个变参函数，因此无需担心线程任务函数的参数个数问题
  - 任务函数`func()`一般返回值指定为`void`，因为子线程在调用这个函数的时候不会处理其返回值

- `thread t1(func1);`：子线程对象`t1`中的任务函数`func1()`，没有参数，因此在线程构造函数中就无需指定了
- 通过线程对象调用`get_id()`就可以知道这个子线程的线程ID了，`t.get_id()`，`t1.get_id()`。

**在上面的示例程序中有一个bug，在主线程中依次创建出两个子线程，打印两个子线程的线程ID，最后主线程执行完毕就退出了（主线程就是执行main()函数的那个线程）。默认情况下，主线程销毁时会将与其关联的两个子线程也一并销毁，但是这时有可能子线程中的任务还没有执行完毕，最后也就得不到我们想要的结果了**。

当启动了一个线程（创建了一个thread对象）之后，在这个线程结束的时候（std::terminate()），我们如何去回收线程所使用的资源呢？thread库给我们两种选择：

- `加入式（join()）`
- `分离式（detach()）`

另外，我们必须要在线程对象销毁之前在二者之间作出选择，否则程序运行期间就会有bug产生。

#### 7.7.2.2 join()

`join()`字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。在某个线程中通过子线程对象调用`join()`函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后`join()`会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。

再次强调，我们一定要搞清楚这个函数阻塞的是哪一个线程，`函数在哪个线程中被执行，那么函数就阻塞哪个线程。`该函数的函数原型如下：

```c++
void join();
```

有了这样一个线程阻塞函数之后，就可以解决在上面测试程序中的bug了，`如果要阻塞主线程的执行，只需要在主线程中通过子线程对象调用这个方法即可，当调用这个方法的子线程对象中的任务函数执行完毕之后，主线程的阻塞也就随之解除了。`修改之后的示例代码如下：

```c++
int main()
{
    cout << "主线程的线程ID: " << this_thread::get_id() << endl;
    thread t(func, 520, "i love you");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
    t.join();
    t1.join();
}
```

当主线程运行到第八行`t.join();`，根据子线程对象`t`的任务函数`func()`的执行情况，主线程会做如下处理：

- 如果任务函数`func()`还没执行完毕，主线程阻塞，直到任务执行完毕，主线程解除阻塞，继续向下运行
- 如果任务函数`func()`已经执行完毕，主线程不会阻塞，继续向下运行

同样，第9行的代码亦如此。

> 为了更好的理解`join()`的使用，再来给大家举一个例子，场景如下：
>
> 程序中一共有三个线程，其中两个子线程负责分段下载同一个文件，下载完毕之后，由主线程对这个文件进行下一步处理，那么示例程序就应该这么写：

```c++
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void download1()
{
    // 模拟下载, 总共耗时500ms，阻塞线程500ms
    this_thread::sleep_for(chrono::milliseconds(500));
    cout << "子线程1: " << this_thread::get_id() << ", 找到历史正文...." << endl;
}

void download2()
{
    // 模拟下载, 总共耗时300ms，阻塞线程300ms
    this_thread::sleep_for(chrono::milliseconds(300));
    cout << "子线程2: " << this_thread::get_id() << ", 找到历史正文...." << endl;
}

void doSomething()
{
    cout << "集齐历史正文, 呼叫罗宾...." << endl;
    cout << "历史正文解析中...." << endl;
    cout << "起航，前往拉夫德尔...." << endl;
    cout << "找到OnePiece, 成为海贼王, 哈哈哈!!!" << endl;
    cout << "若干年后，草帽全员卒...." << endl;
    cout << "大海贼时代再次被开启...." << endl;
}

int main()
{
    thread t1(download1);
    thread t2(download2);
    // 阻塞主线程，等待所有子线程任务执行完毕再继续向下执行
    t1.join();
    t2.join();
    doSomething();
}
```

示例程序输出的结果：

```c++
c++
子线程2: 72540, 找到历史正文....
子线程1: 79776, 找到历史正文....
集齐历史正文, 呼叫罗宾....
历史正文解析中....
起航，前往拉夫德尔....
找到OnePiece, 成为海贼王, 哈哈哈!!!
若干年后，草帽全员卒....
大海贼时代再次被开启....
```

在上面示例程序中最核心的处理是在主线程调用`doSomething();`之前在第`35、36行`通过子线程对象调用了`join()`方法，这样就能够保证两个子线程的任务都执行完毕了，也就是文件内容已经全部下载完成，主线程再对文件进行后续处理，如果子线程的文件没有下载完毕，主线程就去处理文件，很显然从逻辑上讲是有问题的。

#### 7.72.3 detach()

`detach()`函数的作用是进行线程分离，分离主线程和创建出的子线程。`在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。`（其实就是孩子翅膀硬了，和家里断绝关系，自己外出闯荡了，如果家里被诛九族还是会受牵连）。该函数函数原型如下：

```c++
void detach();
```

线程分离函数没有参数也没有返回值，只需要在线程成功之后，通过线程对象调用该函数即可，继续将上面的测试程序修改一下：

```c++
int main()
{
    cout << "主线程的线程ID: " << this_thread::get_id() << endl;
    thread t(func, 520, "i love you");
    thread t1(func1);
    cout << "线程t 的线程ID: " << t.get_id() << endl;
    cout << "线程t1的线程ID: " << t1.get_id() << endl;
    t.detach();
    t1.detach();
    // 让主线程休眠, 等待子线程执行完毕
    this_thread::sleep_for(chrono::seconds(5));
}
```

注意事项：线程分离函数detach()不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或者调用get_id()获取子线程的线程ID。有利就有弊，鱼和熊掌不可兼得，建议使用join()。

#### 7.7.2.5 joinable()

`joinable()`函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：

- 返回值为`true`：主线程和子线程之间有关联（连接）关系
- 返回值为`false`：主线程和子线程之间没有关联（连接）关系

```c++
bool joinable() const noexcept;
```

示例代码如下：

```c++
#include <iostream>
#include <thread>
#include <chrono>
using namespace std;

void foo()
{
    this_thread::sleep_for(std::chrono::seconds(1));
}

int main()
{
    thread t;
    cout << "before starting, joinable: " << t.joinable() << endl;

    t = thread(foo);
    cout << "after starting, joinable: " << t.joinable() << endl;

    t.join();
    cout << "after joining, joinable: " << t.joinable() << endl;

    thread t1(foo);
    cout << "after starting, joinable: " << t1.joinable() << endl;
    t1.detach();
    cout << "after detaching, joinable: " << t1.joinable() << endl;
}
```

示例代码打印的结果如下：

```c++
before starting, joinable: 0
after starting, joinable: 1
after joining, joinable: 0
after starting, joinable: 1
after detaching, joinable: 0
```

基于示例代码打印的结果可以得到以下结论：

- `在创建的子线程对象的时候，如果没有指定任务函数，那么子线程不会启动，主线程和这个子线程也不会进行连接`
- `在创建的子线程对象的时候，如果指定了任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功`
- `子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false`
- `在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。`

#### 7.7.2.6 operator=

`线程中的资源是不能被复制的`，因此通过`=`操作符进行赋值操作最终并不会得到两个完全相同的对象

```c++
// move (1)	
thread& operator= (thread&& other) noexcept;
// copy [deleted] (2)	
thread& operator= (const other&) = delete;
```

通过以上`=`操作符的重载声明可以得知：

- 如果`other`是一个右值，会进行资源所有权的转移
- 如果`other`不是右值，禁止拷贝，该函数被显示删除（`=delete`），不可用

### 7.7.3 静态函数

`thread`线程类还提供了一个静态方法，用于获取当前计算机的CPU核心数，根据这个结果在程序中创建出数量相等的线程，`每个线程独自占有一个CPU核心，这些线程就不用分时复用CPU时间片，此时程序的并发效率是最高的`。

```c++
static unsigned hardware_concurrency() noexcept;
```

示例代码如下：

```c++
#include <iostream>
#include <thread>
using namespace std;

int main()
{
    int num = thread::hardware_concurrency();
    cout << "CPU number: " << num << endl;
}
```

# 八、线程同步

## 8.1 线程同步概念

假设有4个线程A、B、C、D，当前一个线程A对内存中的`共享资源`进行访问的时候，其他线程B, C, D都不可以对这块内存进行操作，直到线程A对这块内存访问完毕为止，B，C，D中的一个才能访问这块内存，剩余的两个需要继续阻塞等待，以此类推，直至所有的线程都对这块内存操作完毕。 线程对内存的这种访问方式就称之为线程同步，通过对概念的介绍，我们可以了解到`所谓的同步并不是多个线程同时对内存进行访问，而是按照先后顺序依次进行的。`

### 8.1.1 为什么要同步

> 在研究线程同步之前，先来看一个两个线程交替数数（每个线程数50个数，交替数到100）的例子：

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <pthread.h>

#define MAX 50
// 全局变量
int number;

// 线程处理函数
void* funcA_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        printf("Thread A, id = %lu, number = %d\n", pthread_self(), number);
    }

    return NULL;
}

void* funcB_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        int cur = number;
        cur++;
        number = cur;
        printf("Thread B, id = %lu, number = %d\n", pthread_self(), number);
        usleep(5);
    }

    return NULL;
}

int main(int argc, const char* argv[])
{
    pthread_t p1, p2;

    // 创建两个子线程
    pthread_create(&p1, NULL, funcA_num, NULL);
    pthread_create(&p2, NULL, funcB_num, NULL);

    // 阻塞，资源回收
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    return 0;
}
```

编译并执行上面的测试程序，得到如下结果：

```c
$ ./a.out 
Thread B, id = 140504473724672, number = 1
Thread B, id = 140504473724672, number = 2
Thread A, id = 140504482117376, number = 2
Thread B, id = 140504473724672, number = 3
Thread A, id = 140504482117376, number = 4
Thread B, id = 140504473724672, number = 5
Thread A, id = 140504482117376, number = 6
Thread B, id = 140504473724672, number = 7
Thread B, id = 140504473724672, number = 8
Thread A, id = 140504482117376, number = 7
Thread B, id = 140504473724672, number = 8
Thread B, id = 140504473724672, number = 9
Thread A, id = 140504482117376, number = 8
Thread B, id = 140504473724672, number = 9
Thread A, id = 140504482117376, number = 9
Thread B, id = 140504473724672, number = 10
Thread B, id = 140504473724672, number = 11
Thread A, id = 140504482117376, number = 10
Thread B, id = 140504473724672, number = 11
Thread A, id = 140504482117376, number = 11
Thread B, id = 140504473724672, number = 12
Thread A, id = 140504482117376, number = 13
Thread B, id = 140504473724672, number = 14
Thread A, id = 140504482117376, number = 15
Thread B, id = 140504473724672, number = 16
Thread B, id = 140504473724672, number = 17
Thread B, id = 140504473724672, number = 18
Thread B, id = 140504473724672, number = 19
Thread A, id = 140504482117376, number = 17
Thread B, id = 140504473724672, number = 18
Thread B, id = 140504473724672, number = 19
Thread A, id = 140504482117376, number = 19
Thread B, id = 140504473724672, number = 20
Thread A, id = 140504482117376, number = 20
Thread B, id = 140504473724672, number = 21
Thread A, id = 140504482117376, number = 21
Thread B, id = 140504473724672, number = 22
Thread A, id = 140504482117376, number = 22
Thread B, id = 140504473724672, number = 23
Thread A, id = 140504482117376, number = 23
Thread B, id = 140504473724672, number = 24
Thread A, id = 140504482117376, number = 24
Thread B, id = 140504473724672, number = 25
Thread A, id = 140504482117376, number = 25
Thread B, id = 140504473724672, number = 26
Thread A, id = 140504482117376, number = 26
Thread B, id = 140504473724672, number = 27
Thread A, id = 140504482117376, number = 27
Thread B, id = 140504473724672, number = 28
Thread A, id = 140504482117376, number = 28
Thread B, id = 140504473724672, number = 29
Thread A, id = 140504482117376, number = 29
Thread B, id = 140504473724672, number = 30
Thread A, id = 140504482117376, number = 30
Thread B, id = 140504473724672, number = 31
Thread A, id = 140504482117376, number = 31
Thread B, id = 140504473724672, number = 32
Thread A, id = 140504482117376, number = 32
Thread B, id = 140504473724672, number = 33
Thread A, id = 140504482117376, number = 33
Thread B, id = 140504473724672, number = 34
Thread A, id = 140504482117376, number = 34
Thread B, id = 140504473724672, number = 35
Thread A, id = 140504482117376, number = 35
Thread B, id = 140504473724672, number = 36
Thread A, id = 140504482117376, number = 36
Thread B, id = 140504473724672, number = 37
Thread A, id = 140504482117376, number = 37
Thread B, id = 140504473724672, number = 38
Thread A, id = 140504482117376, number = 38
Thread B, id = 140504473724672, number = 39
Thread A, id = 140504482117376, number = 39
Thread A, id = 140504482117376, number = 40
Thread B, id = 140504473724672, number = 41
Thread B, id = 140504473724672, number = 42
Thread A, id = 140504482117376, number = 42
Thread A, id = 140504482117376, number = 43
Thread B, id = 140504473724672, number = 44
Thread B, id = 140504473724672, number = 45
Thread A, id = 140504482117376, number = 45
Thread B, id = 140504473724672, number = 46
Thread A, id = 140504482117376, number = 46
Thread B, id = 140504473724672, number = 47
Thread A, id = 140504482117376, number = 47
Thread B, id = 140504473724672, number = 48
Thread A, id = 140504482117376, number = 48
Thread B, id = 140504473724672, number = 49
Thread A, id = 140504482117376, number = 50
Thread B, id = 140504473724672, number = 51
Thread A, id = 140504482117376, number = 51
Thread B, id = 140504473724672, number = 52
Thread A, id = 140504482117376, number = 53
Thread A, id = 140504482117376, number = 54
Thread A, id = 140504482117376, number = 55
Thread A, id = 140504482117376, number = 56
Thread A, id = 140504482117376, number = 57
Thread A, id = 140504482117376, number = 58
Thread A, id = 140504482117376, number = 59
Thread A, id = 140504482117376, number = 60
Thread A, id = 140504482117376, number = 61
robin@OS:~/abc/b$ 
```

通过对上面例子的测试，可以看出虽然每个线程内部循环了50次每次数一个数，但是最终没有数到100，通过输出的结果可以看到，有些数字被重复数了多次，其原因就是没有对线程进行同步处理，造成了数据的混乱。

两个线程在数数的时候需要分时复用CPU时间片，并且测试程序中调用了`sleep()`导致线程的CPU时间片没用完就被迫挂起了，这样就能让CPU的上下文切换（保存当前状态, 下一次继续运行的时候需要加载保存的状态）更加频繁，更容易再现数据混乱的这个现象。

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/1568967847637.png)](https://subingwen.cn/linux/thread-sync/1568967847637.png)

CPU对应寄存器、一级缓存、二级缓存、三级缓存是独占的，用于存储处理的数据和线程的状态信息，数据被CPU处理完成需要再次被写入到物理内存中，物理内存数据也可以通过文件IO操作写入到磁盘中。

在测试程序中两个线程共用全局变量`number`当线程变成运行态之后开始数数，从物理内存加载数据，让后将数据放到CPU进行运算，最后将结果更新到物理内存中。如果数数的两个线程都可以顺利完成这个流程，那么得到的结果肯定是正确的。

如果线程A执行这个过程期间就失去了CPU时间片，线程A被挂起了最新的数据没能更新到物理内存。线程B变成运行态之后从物理内存读数据，很显然它没有拿到最新数据，只能基于旧的数据往后数，然后失去CPU时间片挂起。线程A得到CPU时间片变成运行态，第一件事儿就是将上次没更新到内存的数据更新到内存，但是这样会导致线程B已经更新到内存的数据被覆盖，活儿白干了，最终导致有些数据会被重复数很多次。

### 8.1.2 同步方式

对于多个线程访问共享资源出现数据混乱的问题，需要进行线程同步。常用的线程同步方式有四种：**互斥锁**、**读写锁**、**条件变量**、**信号量**。所谓的共享资源就是多个线程共同访问的变量，这些变量通常为全局数据区变量或者堆区变量，这些变量对应的共享资源也被称之为**临界资源**。

[![image-20200106092600543](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/image-20200106092600543.png)](https://subingwen.cn/linux/thread-sync/image-20200106092600543.png)

找到临界资源之后，再找和临界资源相关的上下文代码，这样就得到了一个代码块，这个代码块可以称之为**临界区**。确定好临界区（==临界区越小越好==）之后，就可以进行线程同步了，线程同步的大致处理思路是这样的：

- 在临界区代码的上边，添加加锁函数，对临界区加锁。
  - 哪个线程调用这句代码，就会把这把锁锁上，其他线程就只能阻塞在锁上了。
- 在临界区代码的下边，添加解锁函数，对临界区解锁。
  - 出临界区的线程会将锁定的那把锁打开，其他抢到锁的线程就可以进入到临界区了。
- 通过锁机制能保证临界区代码最多只能同时有一个线程访问，这样并行访问就变为串行访问了。

## 8.2 互斥锁

### 8.2.1 互斥锁函数

**互斥锁**是线程同步最常用的一种方式，通过互斥锁可以锁定一个代码块, 被锁定的这个代码块, 所有的线程只能顺序执行(不能并行处理)，这样多线程访问共享资源数据混乱的问题就可以被解决了，需要付出的代价就是执行效率的降低，因为默认临界区多个线程是可以并行处理的，现在只能串行处理。

在Linux中互斥锁的类型为`pthread_mutex_t`，创建一个这种类型的变量就得到了一把互斥锁：

```c
pthread_mutex_t  mutex;
```

在创建的锁对象中保存了当前这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程ID）。一个互斥锁变量只能被一个线程锁定，被锁定之后其他线程再对互斥锁变量加锁就会被阻塞，直到这把互斥锁被解锁，被阻塞的线程才能被解除阻塞。`一般情况下，每一个共享资源对应一个把互斥锁，锁的个数和线程的个数无关。`

> Linux 提供的互斥锁操作函数如下，如果函数调用成功会返回0，调用失败会返回相应的错误号：

```c
// 初始化互斥锁
// restrict: 是一个关键字, 用来修饰指针, 只有这个关键字修饰的指针可以访问指向的内存地址, 其他指针是不行的
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
           const pthread_mutexattr_t *restrict attr);
// 释放互斥锁资源            
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

- **参数**:
  - **mutex**: 互斥锁变量的地址
  - **attr**: 互斥锁的属性, 一般使用默认属性即可, 这个参数指定为NULL

```c
// 修改互斥锁的状态, 将其设定为锁定状态, 这个状态被写入到参数 mutex 中
int pthread_mutex_lock(pthread_mutex_t *mutex);
```

这个函数被调用, 首先会判断参数 mutex 互斥锁中的状态是不是锁定状态:

- 没有被锁定, 是打开的, 这个线程可以加锁成功, 这个这个锁中会记录是哪个线程加锁成功了
- 如果被锁定了, 其他线程加锁就失败了, 这些线程都会阻塞在这把锁上
- 当这把锁被解开之后, 这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞

```c
// 尝试加锁
int pthread_mutex_trylock(pthread_mutex_t *mutex);
```

调用这个函数对互斥锁变量加锁还是有两种情况:

- 如果这把锁没有被锁定是打开的，线程加锁成功
- 如果锁变量被锁住了，调用这个函数加锁的线程，不会被阻塞，加锁失败直接返回错误号

```c
// 对互斥锁解锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

### 8.2.1 互斥锁使用

我们可以将上面多线程交替数数的例子修改一下，使用互斥锁进行线程同步。两个线程一共操作了同一个全局变量，因此需要添加一互斥锁，来控制这两个线程。

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <pthread.h>

#define MAX 100
// 全局变量
int number;

// 创建一把互斥锁
// 全局变量, 多个线程共享
pthread_mutex_t mutex;

// 线程处理函数
void* funcA_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        // 如果线程A加锁成功, 不阻塞
        // 如果B加锁成功, 线程A阻塞
        pthread_mutex_lock(&mutex);
        int cur = number;
        cur++;
        usleep(10);
        number = cur;
        pthread_mutex_unlock(&mutex);
        printf("Thread A, id = %lu, number = %d\n", pthread_self(), number);
    }

    return NULL;
}

void* funcB_num(void* arg)
{
    for(int i=0; i<MAX; ++i)
    {
        // a加锁成功, b线程访问这把锁的时候是锁定的
        // 线程B先阻塞, a线程解锁之后阻塞解除
        // 线程B加锁成功了
        pthread_mutex_lock(&mutex);
        int cur = number;
        cur++;
        number = cur;
        pthread_mutex_unlock(&mutex);
        printf("Thread B, id = %lu, number = %d\n", pthread_self(), number);
        usleep(5);
    }

    return NULL;
}

int main(int argc, const char* argv[])
{
    pthread_t p1, p2;

    // 初始化互斥锁
    pthread_mutex_init(&mutex, NULL);

    // 创建两个子线程
    pthread_create(&p1, NULL, funcA_num, NULL);
    pthread_create(&p2, NULL, funcB_num, NULL);

    // 阻塞，资源回收
    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    // 销毁互斥锁
    // 线程销毁之后, 再去释放互斥锁
    pthread_mutex_destroy(&mutex);

    return 0;
}
```

## 8.3 死锁

当多个线程访问共享资源, 需要加锁, 如果锁使用不当, 就会造成死锁这种现象。如果线程死锁造成的后果是：所有的线程都被阻塞，并且线程的阻塞是无法解开的（因为可以解锁的线程也被阻塞了）。

造成死锁的场景有如下几种：

- 加锁之后忘记解锁

  ```c
  // 场景1
  void func()
  {
      for(int i=0; i<6; ++i)
      {
          // 当前线程A加锁成功, 当前循环完毕没有解锁, 在下一轮循环的时候自己被阻塞了
          // 其余的线程也被阻塞
      	pthread_mutex_lock(&mutex);
      	....
      	.....
          // 忘记解锁
      }
  }
  
  // 场景2
  void func()
  {
      for(int i=0; i<6; ++i)
      {
          // 当前线程A加锁成功
          // 其余的线程被阻塞
      	pthread_mutex_lock(&mutex);
      	....
      	.....
          if(xxx)
          {
              // 函数退出, 没有解锁（解锁函数无法被执行了）
              return ;
          }
          
          pthread_mutex_lock(&mutex);
      }
  }
  
  ```

- 重复加锁, 造成死锁

  ```c
  void func()
  {
      for(int i=0; i<6; ++i)
      {
          // 当前线程A加锁成功
          // 其余的线程阻塞
      	pthread_mutex_lock(&mutex);
          // 锁被锁住了, A线程阻塞
          pthread_mutex_lock(&mutex);
      	....
      	.....
          pthread_mutex_unlock(&mutex);
      }
  }
  
  // 隐藏的比较深的情况
  void funcA()
  {
      for(int i=0; i<6; ++i)
      {
          // 当前线程A加锁成功
          // 其余的线程阻塞
      	pthread_mutex_lock(&mutex);
      	....
      	.....
          pthread_mutex_unlock(&mutex);
      }
  }
  
  void funcB()
  {
      for(int i=0; i<6; ++i)
      {
          // 当前线程A加锁成功
          // 其余的线程阻塞
      	pthread_mutex_lock(&mutex);
          funcA();		// 重复加锁
      	....
      	.....
          pthread_mutex_unlock(&mutex);
      }
  }
  ```

- 在程序中有多个共享资源, 因此有很多把锁，随意加锁，导致相互被阻塞

  ```
  场景描述:
    1. 有两个共享资源:X, Y，X对应锁A, Y对应锁B
       - 线程A访问资源X, 加锁A
       - 线程B访问资源Y, 加锁B
    2. 线程A要访问资源Y, 线程B要访问资源X，因为资源X和Y已经被对应的锁锁住了，因此这个两个线程被阻塞
       - 线程A被锁B阻塞了, 无法打开A锁
       - 线程B被锁A阻塞了, 无法打开B锁
  ```

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/1557806644326.png)](https://subingwen.cn/linux/thread-sync/1557806644326.png)

在使用多线程编程的时候，如何避免死锁呢？

- 避免多次锁定, 多检查
- 对共享资源访问完毕之后, 一定要解锁，或者在加锁的使用 trylock
- 如果程序中有多把锁, 可以控制对锁的访问顺序(顺序访问共享资源，但在有些情况下是做不到的)，另外也可以在对其他互斥锁做加锁操作之前，先释放当前线程拥有的互斥锁。
- 项目程序中可以引入一些专门用于死锁检测的模块

## 8.4 读写锁

### 8.4.1 读写锁函数

读写锁是互斥锁的升级版, `在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的`，但是使用互斥锁，读操作也是串行的。

读写锁是一把锁，锁的类型为`pthread_rwlock_t`，有了类型之后就可以创建一把互斥锁了：

```c
pthread_rwlock_t rwlock;
```

之所以称其为读写锁，是因为这把锁既可以锁定读操作，也可以锁定写操作。为了方便理解，可以大致认为在这把锁中记录了这些信息：

- 锁的状态: 锁定/打开
- 锁定的是什么操作: 读操作/写操作，`使用读写锁锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。`
- 哪个线程将这把锁锁上了

读写锁的使用方式也互斥锁的使用方式是完全相同的：找共享资源, 确定临界区，在临界区的开始位置加锁（读锁/写锁），临界区的结束位置解锁。

因为通过一把读写锁可以锁定读或者写操作，下面介绍一下关于读写锁的特点：

1. 使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，`读锁是共享的。`
2. 使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，`写锁是独占的。`
3. 使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为`写锁比读锁的优先级高。`

**如果说程序中所有的线程都对共享资源做写操作，使用读写锁没有优势，和互斥锁是一样的，如果说程序中所有的线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。**

> Linux提供的读写锁操作函数原型如下，如果函数调用成功返回0，失败返回对应的错误号：

```c
#include <pthread.h>
pthread_rwlock_t rwlock;
// 初始化读写锁
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
           const pthread_rwlockattr_t *restrict attr);
// 释放读写锁占用的系统资源
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
```

- 参数:
  - rwlock: 读写锁的地址，传出参数
  - attr: 读写锁属性，一般使用默认属性，指定为NULL

```c
// 在程序中对读写锁加读锁, 锁定的是读操作
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
```

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被阻塞。

```c
// 这个函数可以有效的避免死锁
// 如果加读锁失败, 不会阻塞当前线程, 直接返回错误号
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
```

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。

```c
// 在程序中对读写锁加写锁, 锁定的是写操作
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
```

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。

```c
// 这个函数可以有效的避免死锁
// 如果加写锁失败, 不会阻塞当前线程, 直接返回错误号
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
```

调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。

```c
// 解锁, 不管锁定了读还是写都可用解锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
```

### 8.4.2 读写锁使用

题目要求：8个线程操作同一个全局变量，3个线程不定时写同一全局资源，5个线程不定时读同一全局资源。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 全局变量
int number = 0;

// 定义读写锁
pthread_rwlock_t rwlock;

// 写的线程的处理函数
void* writeNum(void* arg)
{
    while(1)
    {
        pthread_rwlock_wrlock(&rwlock);
        int cur = number;
        cur ++;
        number = cur;
        printf("++写操作完毕, number : %d, tid = %ld\n", number, pthread_self());
        pthread_rwlock_unlock(&rwlock);
        // 添加sleep目的是要看到多个线程交替工作
        usleep(rand() % 100);
    }

    return NULL;
}

// 读线程的处理函数
// 多个线程可以如果处理动作相同, 可以使用相同的处理函数
// 每个线程中的栈资源是独享
void* readNum(void* arg)
{
    while(1)
    {
        pthread_rwlock_rdlock(&rwlock);
        printf("--全局变量number = %d, tid = %ld\n", number, pthread_self());
        pthread_rwlock_unlock(&rwlock);
        usleep(rand() % 100);
    }
    return NULL;
}

int main()
{
    // 初始化读写锁
    pthread_rwlock_init(&rwlock, NULL);

    // 3个写线程, 5个读的线程
    pthread_t wtid[3];
    pthread_t rtid[5];
    for(int i=0; i<3; ++i)
    {
        pthread_create(&wtid[i], NULL, writeNum, NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_create(&rtid[i], NULL, readNum, NULL);
    }

    // 释放资源
    for(int i=0; i<3; ++i)
    {
        pthread_join(wtid[i], NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_join(rtid[i], NULL);
    }

    // 销毁读写锁
    pthread_rwlock_destroy(&rwlock);

    return 0;
}
```

## 8.5 条件变量

### 8.5.1 条件变量函数

严格意义上来说，条件变量的主要作用不是处理线程同步, `而是进行线程的阻塞。`如果在多线程程序中只使用条件变量无法实现线程的同步, 必须要配合互斥锁来使用。虽然条件变量和互斥锁都能阻塞线程，但是二者的效果是不一样的，二者的区别如下：

- 假设有A-Z 26个线程，这26个线程共同访问同一把互斥锁，如果线程A加锁成功，那么其余B-Z线程访问互斥锁都阻塞，所有的线程只能顺序访问临界区
- 条件变量只有在满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写临界资源，这种情况下还是会出现共享资源中数据的混乱。

一般情况下条件变量用于处理生产者和消费者模型，并且和互斥锁配合使用。条件变量类型对应的类型为`pthread_cond_t`，这样就可以定义一个条件变量类型的变量了：

```c
pthread_cond_t cond;
```

被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。

> 条件变量操作函数函数原型如下：

```c
#include <pthread.h>
pthread_cond_t cond;
// 初始化
int pthread_cond_init(pthread_cond_t *restrict cond,
      const pthread_condattr_t *restrict attr);
// 销毁释放资源        
int pthread_cond_destroy(pthread_cond_t *cond);
```

- 参数:
  - cond: 条件变量的地址
  - attr: 条件变量属性, 一般使用默认属性, 指定为NULL

```c
// 线程阻塞函数, 哪个线程调用这个函数, 哪个线程就会被阻塞
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
```

通过函数原型可以看出，该函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁主要功能是进行线程同步，让线程顺序进入临界区，避免出现数共享资源的数据混乱。该函数会对这个互斥锁做以下几件事情：

1. 在阻塞线程时候，如果线程已经对互斥锁`mutex`上锁，那么会将这把锁打开，这样做是为了避免死锁
2. 当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个`mutex`互斥锁锁上，继续向下访问临界区

```c
// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示
struct timespec {
	time_t tv_sec;      /* Seconds */
	long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */
};
// 将线程阻塞一定的时间长度, 时间到达之后, 线程就解除阻塞了
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
           pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
```

这个函数的前两个参数和`pthread_cond_wait`函数是一样的，第三个参数表示线程阻塞的时长，但是需要额外注意一点：`struct timespec`这个结构体中记录的时间是`从1971.1.1到某个时间点的时间，总长度使用秒/纳秒表示。`因此赋值方式相对要麻烦一点：

```c
time_t mytim = time(NULL);	// 1970.1.1 0:0:0 到当前的总秒数
struct timespec tmsp;
tmsp.tv_nsec = 0;
tmsp.tv_sec = time(NULL) + 100;	// 线程阻塞100s
```

```c
// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞
int pthread_cond_signal(pthread_cond_t *cond);
// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞
int pthread_cond_broadcast(pthread_cond_t *cond);
```

调用上面两个函数中的任意一个，都可以换线被`pthread_cond_wait`或者`pthread_cond_timedwait`阻塞的线程，区别就在于`pthread_cond_signal`是唤醒至少一个被阻塞的线程（总个数不定），`pthread_cond_broadcast`是唤醒所有被阻塞的线程。

## 5.2 生产者和消费者

生产者和消费者模型的组成：

1. 生产者线程 -> 若干个
   - 生产商品或者任务放入到任务队列中
   - 任务队列满了就阻塞, 不满的时候就工作
   - 通过一个生产者的条件变量控制生产者线程阻塞和非阻塞
2. 消费者线程 -> 若干个
   - 读任务队列, 将任务或者数据取出
   - 任务队列中有数据就消费，没有数据就阻塞
   - 通过一个消费者的条件变量控制消费者线程阻塞和非阻塞
3. 队列 -> 存储任务/数据，对应一块内存，为了读写访问可以通过一个数据结构维护这块内存
   - 可以是数组、链表，也可以使用stl容器：queue / stack / list / vector

[![img](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/1564644834918.png)](https://subingwen.cn/linux/thread-sync/1564644834918.png)

> 场景描述：使用条件变量实现生产者和消费者模型，生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

// 链表的节点
struct Node
{
    int number;
    struct Node* next;
};

// 定义条件变量, 控制消费者线程
pthread_cond_t cond;
// 互斥锁变量
pthread_mutex_t mutex;
// 指向头结点的指针
struct Node * head = NULL;

// 生产者的回调函数
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 创建一个链表的新节点
        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
        // 节点初始化
        pnew->number = rand() % 1000;
        // 节点的连接, 添加到链表的头部, 新节点就新的头结点
        pnew->next = head;
        // head指针前移
        head = pnew;
        printf("+++producer, number = %d, tid = %ld\n", pnew->number, pthread_self());
        pthread_mutex_unlock(&mutex);

        // 生产了任务, 通知消费者消费
        pthread_cond_broadcast(&cond);

        // 生产慢一点
        sleep(rand() % 3);
    }
    return NULL;
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 一直消费, 删除链表中的一个节点
//        if(head == NULL)   // 这样写有bug
        while(head == NULL)
        {
            // 任务队列, 也就是链表中已经没有节点可以消费了
            // 消费者线程需要阻塞
            // 线程加互斥锁成功, 但是线程阻塞在这行代码上, 锁还没解开
            // 其他线程在访问这把锁的时候也会阻塞, 生产者也会阻塞 ==> 死锁
            // 这函数会自动将线程拥有的锁解开
            pthread_cond_wait(&cond, &mutex);
            // 当消费者线程解除阻塞之后, 会自动将这把锁锁上
            // 这时候当前这个线程又重新拥有了这把互斥锁
        }
        // 取出链表的头结点, 将其删除
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        free(pnode);
        pthread_mutex_unlock(&mutex);        

        sleep(rand() % 3);
    }
    return NULL;
}

int main()
{
    // 初始化条件变量
    pthread_cond_init(&cond, NULL);
    pthread_mutex_init(&mutex, NULL);

    // 创建5个生产者, 5个消费者
    pthread_t ptid[5];
    pthread_t ctid[5];
    for(int i=0; i<5; ++i)
    {
        pthread_create(&ptid[i], NULL, producer, NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_create(&ctid[i], NULL, consumer, NULL);
    }

    // 释放资源
    for(int i=0; i<5; ++i)
    {
        // 阻塞等待子线程退出
        pthread_join(ptid[i], NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_join(ctid[i], NULL);
    }

    // 销毁条件变量
    pthread_cond_destroy(&cond);
    pthread_mutex_destroy(&mutex);

    return 0;
}
```

代码分析

```c
void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 一直消费, 删除链表中的一个节点
        if(head == NULL)   // 这样写有bug
        {
            pthread_cond_wait(&cond, &mutex);
        }
        // 取出链表的头结点, 将其删除
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        free(pnode);
        pthread_mutex_unlock(&mutex);        

        sleep(rand() % 3);
    }
    return NULL;
}

/*
为什么在第7行使用if 有bug:
    当任务队列为空, 所有的消费者线程都会被这个函数阻塞 pthread_cond_wait(&cond, &mutex);
    也就是阻塞在代码的第9行
	
    当生产者生产了1个节点, 调用 pthread_cond_broadcast(&cond); 唤醒了所有阻塞的线程
      - 有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞
      - 加锁成功的线程向下运行, 并成功删除一个节点, 然后解锁
      - 没有加锁成功的线程解除阻塞继续抢这把锁, 另外一个子线程加锁成功
      - 但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点的时候就会出现段错误
    解决方案:
      - 需要循环的对链表是否为空进行判断, 需要将if 该成 while
*/
```

## 8.6 信号量

### 8.6.1 信号量函数

信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作。信号量不一定是锁定某一个资源，而是流程上的概念，比如：有A，B两个线程，B线程要等A线程完成某一任务以后再进行自己下面的步骤，这个任务并不一定是锁定某一资源，还可以是进行一些计算或者数据处理之类。

`信号量（信号灯）`与互斥锁和条件变量的主要不同在于”灯”的概念，灯亮则意味着资源可用，灯灭则意味着不可用。信号量主要阻塞线程, 不能完全保证线程安全，如果要保证线程安全, 需要信号量和互斥锁一起使用。

信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或者消费者线程的运行。信号的类型为`sem_t`对应的头文件为`<semaphore.h>`：

```c
#include <semaphore.h>
sem_t sem;
```

Linux提供的信号量操作函数原型如下：

```c
#include <semaphore.h>
// 初始化信号量/信号灯
int sem_init(sem_t *sem, int pshared, unsigned int value);
// 资源释放, 线程销毁之后调用这个函数即可
// 参数 sem 就是 sem_init() 的第一个参数            
int sem_destroy(sem_t *sem);
```

- 参数:
  - sem：信号量变量地址
  - pshared：
    - 0：线程同步
    - 非0：进程同步
  - value：初始化当前信号量拥有的资源数（>=0），如果资源数为0，线程就会被阻塞了。

```c
// 参数 sem 就是 sem_init() 的第一个参数  
// 函数被调用sem中的资源就会被消耗1个, 资源数-1
int sem_wait(sem_t *sem);
```

当线程调用这个函数，并且`sem`中的资源数`>0`，线程不会阻塞，线程会占用`sem`中的一个资源，因此资源数-1，直到`sem`中的资源数减为`0`时，资源被耗尽，因此线程也就被阻塞了。

```c
// 参数 sem 就是 sem_init() 的第一个参数  
// 函数被调用sem中的资源就会被消耗1个, 资源数-1
int sem_trywait(sem_t *sem);
```

当线程调用这个函数，并且`sem`中的资源数`>0`，线程不会阻塞，线程会占用`sem`中的一个资源，因此资源数-1，直到`sem`中的资源数减为`0`时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。

```c
// 表示的时间是从1971.1.1到某个时间点的时间, 总长度使用秒/纳秒表示
struct timespec {
	time_t tv_sec;      /* Seconds */
	long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */
};
// 调用该函数线程获取sem中的一个资源，当资源数为0时，线程阻塞，在阻塞abs_timeout对应的时长之后，解除阻塞。
// abs_timeout: 阻塞的时间长度, 单位是s, 是从1970.1.1开始计算的
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
```

该函数的参数`abs_timeout`和`pthread_cond_timedwait`的最后一个参数是一样的，使用方法不再过多赘述。当线程调用这个函数，并且`sem`中的资源数`>0`，线程不会阻塞，线程会占用`sem`中的一个资源，因此资源数-1，直到`sem`中的资源数减为`0`时，资源被耗尽，线程被阻塞，当阻塞指定的时长之后，线程解除阻塞。

```c
// 调用该函数给sem中的资源数+1
int sem_post(sem_t *sem);
```

调用该函数会将`sem`中的资源数`+1`，如果有线程在调用`sem_wait`、`sem_trywait`、`sem_timedwait`时因为`sem`中的资源数为`0`被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。

```c
// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中
// sval是一个传出参数
int sem_getvalue(sem_t *sem, int *sval);
```

通过这个函数可以查看`sem`中现在拥有的资源个数，通过第二个参数`sval`将数据传出，也就是说第二个参数的作用和返回值是一样的。

### 8.6.2 生产者和消费者

由于生产者和消费者是两类线程，并且在还没有生成之前是不能进行消费的，在使用信号量处理这类问题的时候可以定义两个信号量，分别用于记录生产者和消费者线程拥有的总资源数。

```c
// 生产者线程 
sem_t psem;
// 消费者线程
sem_t csem;

// 信号量初始化
sem_init(&psem, 0, 5);    // 5个生产者可以同时生产
sem_init(&csem, 0, 0);    // 消费者线程没有资源, 因此不能消费

// 生产者线程
// 在生产之前, 从信号量中取出一个资源
sem_wait(&psem);	
// 生产者商品代码, 有商品了, 放到任务队列
......	 
......
......
// 通知消费者消费，给消费者信号量添加资源，让消费者解除阻塞
sem_post(&csem);
	
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// 消费者线程
// 消费者需要等待生产, 默认启动之后应该阻塞
sem_wait(&csem);
// 开始消费
......
......
......
// 消费完成, 通过生产者生产，给生产者信号量添加资源
sem_post(&psem);
```

通过上面的代码可以知道，初始化信号量的时候没有消费者分配资源，消费者线程启动之后由于没有资源自然就被阻塞了，等生产者生产出产品之后，再给消费者分配资源，这样二者就可以配合着完成生产和消费流程了。

### 8.6.3 信号量使用

> 场景描述：使用信号量实现生产者和消费者模型，生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点。

#### 8.6.3.1 总资源数为1

如果生产者和消费者线程使用的信号量对应的总资源数为1，那么不管线程有多少个，可以工作的线程只有一个，其余线程由于拿不到资源，都被迫阻塞了。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <semaphore.h>
#include <pthread.h>

// 链表的节点
struct Node
{
    int number;
    struct Node* next;
};

// 生产者线程信号量
sem_t psem;
// 消费者线程信号量
sem_t csem;

// 互斥锁变量
pthread_mutex_t mutex;
// 指向头结点的指针
struct Node * head = NULL;

// 生产者的回调函数
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        // 生产者拿一个信号灯
        sem_wait(&psem);
        // 创建一个链表的新节点
        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
        // 节点初始化
        pnew->number = rand() % 1000;
        // 节点的连接, 添加到链表的头部, 新节点就新的头结点
        pnew->next = head;
        // head指针前移
        head = pnew;
        printf("+++producer, number = %d, tid = %ld\n", pnew->number, pthread_self());

        // 通知消费者消费, 给消费者加信号灯
        sem_post(&csem);
        

        // 生产慢一点
        sleep(rand() % 3);
    }
    return NULL;
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        sem_wait(&csem);
        // 取出链表的头结点, 将其删除
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        free(pnode);
        // 通知生产者生成, 给生产者加信号灯
        sem_post(&psem);

        sleep(rand() % 3);
    }
    return NULL;
}

int main()
{
    // 初始化信号量
    // 生产者和消费者拥有的信号灯的总和为1
    sem_init(&psem, 0, 1);  // 生成者线程一共有1个信号灯
    sem_init(&csem, 0, 0);  // 消费者线程一共有0个信号灯

    // 创建5个生产者, 5个消费者
    pthread_t ptid[5];
    pthread_t ctid[5];
    for(int i=0; i<5; ++i)
    {
        pthread_create(&ptid[i], NULL, producer, NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_create(&ctid[i], NULL, consumer, NULL);
    }

    // 释放资源
    for(int i=0; i<5; ++i)
    {
        pthread_join(ptid[i], NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_join(ctid[i], NULL);
    }

    sem_destroy(&psem);
    sem_destroy(&csem);

    return 0;
}
```

**通过测试代码可以得到如下结论：如果生产者和消费者使用的信号量总资源数为1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的**。

#### 8.6.3.2 总资源数大于1

如果生产者和消费者线程使用的信号量对应的总资源数为大于1，这种场景下出现的情况就比较多了：

- 多个生产者线程同时生产
- 多个消费者同时消费
- 生产者线程和消费者线程同时生产和消费

以上不管哪一种情况都可能会出现多个线程访问共享资源的情况，如果想防止共享资源出现数据混乱，那么就需要使用互斥锁进行线程同步，处理代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <semaphore.h>
#include <pthread.h>

// 链表的节点
struct Node
{
    int number;
    struct Node* next;
};

// 生产者线程信号量
sem_t psem;
// 消费者线程信号量
sem_t csem;

// 互斥锁变量
pthread_mutex_t mutex;
// 指向头结点的指针
struct Node * head = NULL;

// 生产者的回调函数
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        // 生产者拿一个信号灯
        sem_wait(&psem);
        // 加锁, 这句代码放到 sem_wait()上边, 有可能会造成死锁
        pthread_mutex_lock(&mutex);
        // 创建一个链表的新节点
        struct Node* pnew = (struct Node*)malloc(sizeof(struct Node));
        // 节点初始化
        pnew->number = rand() % 1000;
        // 节点的连接, 添加到链表的头部, 新节点就新的头结点
        pnew->next = head;
        // head指针前移
        head = pnew;
        printf("+++producer, number = %d, tid = %ld\n", pnew->number, pthread_self());
        pthread_mutex_unlock(&mutex);

        // 通知消费者消费
        sem_post(&csem);
        
        // 生产慢一点
        sleep(rand() % 3);
    }
    return NULL;
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        sem_wait(&csem);
        pthread_mutex_lock(&mutex);
        struct Node* pnode = head;
        printf("--consumer: number: %d, tid = %ld\n", pnode->number, pthread_self());
        head  = pnode->next;
        // 取出链表的头结点, 将其删除
        free(pnode);
        pthread_mutex_unlock(&mutex);
        // 通知生产者生成, 给生产者加信号灯
        sem_post(&psem);

        sleep(rand() % 3);
    }
    return NULL;
}

int main()
{
    // 初始化信号量
    sem_init(&psem, 0, 5);  // 生成者线程一共有5个信号灯
    sem_init(&csem, 0, 0);  // 消费者线程一共有0个信号灯
    // 初始化互斥锁
    pthread_mutex_init(&mutex, NULL);

    // 创建5个生产者, 5个消费者
    pthread_t ptid[5];
    pthread_t ctid[5];
    for(int i=0; i<5; ++i)
    {
        pthread_create(&ptid[i], NULL, producer, NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_create(&ctid[i], NULL, consumer, NULL);
    }

    // 释放资源
    for(int i=0; i<5; ++i)
    {
        pthread_join(ptid[i], NULL);
    }

    for(int i=0; i<5; ++i)
    {
        pthread_join(ctid[i], NULL);
    }

    sem_destroy(&psem);
    sem_destroy(&csem);
    pthread_mutex_destroy(&mutex);

    return 0;
}
```

在编写上述代码的时候还有一个需要注意是事项，不管是消费者线程的处理函数还是生产者线程的处理函数内部有这么两行代码：

```c
// 消费者
sem_wait(&csem);
pthread_mutex_lock(&mutex);

// 生产者
sem_wait(&csem);
pthread_mutex_lock(&mutex);
```

这两行代码的调用顺序是不能颠倒的，如果颠倒过来就有可能会造成死锁，下面来分析一种死锁的场景：

```c
void* producer(void* arg)
{
    // 一直生产
    while(1)
    {
        pthread_mutex_lock(&mutex);
        // 生产者拿一个信号灯
        sem_wait(&psem);
		......
        ......
        // 通知消费者消费
        sem_post(&csem);
        pthread_mutex_unlock(&mutex);
        
        // 生产慢一点
        sleep(rand() % 3);
    }
    return NULL;
}

// 消费者的回调函数
void* consumer(void* arg)
{
    while(1)
    {
        pthread_mutex_lock(&mutex);
        sem_wait(&csem);
		......
        ......
        // 通知生产者生成, 给生产者加信号灯
        sem_post(&psem);
        pthread_mutex_unlock(&mutex);

        sleep(rand() % 3);
    }
    return NULL;
}

int main()
{
    // 初始化信号量
    sem_init(&psem, 0, 5);  // 生成者线程一共有5个信号灯
    sem_init(&csem, 0, 0);  // 消费者线程一共有0个信号灯
	......
	......
    return 0;
}
```

在上面的代码中，初始化状态下消费者线程没有任务信号量资源，假设某一个消费者线程先运行，调用`pthread_mutex_lock(&mutex);`对互斥锁加锁成功，然后调用`sem_wait(&csem);`由于没有资源，因此被阻塞了。其余的消费者线程由于没有抢到互斥锁，因此被阻塞在互斥锁上。对应生产者线程第一步操作也是调用`pthread_mutex_lock(&mutex);`，但是这时候互斥锁已经被消费者线程锁上了，所有生产者都被阻塞，到此为止，多余的线程都被阻塞了，程序产生了死锁。

# 九、线程池——C语言版

## 9.1 线程池原理

我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？

线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。

在各个编程语言的语种中都有线程池的概念，并且很多语言中直接提供了线程池，作为程序猿直接使用就可以了，下面给大家介绍一下线程池的实现原理：

- 线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：
  1. **任务队列，存储需要处理的任务，由工作的线程来处理这些任务**
     - 通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除
     - 已处理的任务会被从任务队列中删除
     - 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程
  2. **工作的线程（任务队列任务的消费者） ，N个**
     - 线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理
     - 工作的线程相当于是任务队列的消费者角色，
     - 如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量/信号量阻塞)
     - 如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作
  3. **管理者线程（不处理任务队列中的任务），1个**
     - 它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测
       - 当任务过多的时候, 可以适当的创建一些新的工作线程
       - 当任务过少的时候, 可以适当的销毁一些工作的线程

[![查看源图像](Linux%E6%95%99%E7%A8%8B3%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.assets/R9c00030b842edb1ae3d6a2b286e53916)](https://subingwen.cn/linux/threadpool/R9c00030b842edb1ae3d6a2b286e53916)

## 9.2 任务队列

```c
// 任务结构体
typedef struct Task
{
    void (*function)(void* arg);
    void* arg;
}Task;
```

## 9.3 线程池定义

```c
// 线程池结构体
struct ThreadPool
{
    // 任务队列
    Task* taskQ;
    int queueCapacity;  // 容量
    int queueSize;      // 当前任务个数
    int queueFront;     // 队头 -> 取数据
    int queueRear;      // 队尾 -> 放数据

    pthread_t managerID;    // 管理者线程ID
    pthread_t *threadIDs;   // 工作的线程ID
    int minNum;             // 最小线程数量
    int maxNum;             // 最大线程数量
    int busyNum;            // 忙的线程的个数
    int liveNum;            // 存活的线程的个数
    int exitNum;            // 要销毁的线程个数
    pthread_mutex_t mutexPool;  // 锁整个的线程池
    pthread_mutex_t mutexBusy;  // 锁busyNum变量
    pthread_cond_t notFull;     // 任务队列是不是满了
    pthread_cond_t notEmpty;    // 任务队列是不是空了

    int shutdown;           // 是不是要销毁线程池, 销毁为1, 不销毁为0
};
```

## 9.4 头文件声明

```c
#ifndef _THREADPOOL_H
#define _THREADPOOL_H

typedef struct ThreadPool ThreadPool;
// 创建线程池并初始化
ThreadPool *threadPoolCreate(int min, int max, int queueSize);

// 销毁线程池
int threadPoolDestroy(ThreadPool* pool);

// 给线程池添加任务
void threadPoolAdd(ThreadPool* pool, void(*func)(void*), void* arg);

// 获取线程池中工作的线程的个数
int threadPoolBusyNum(ThreadPool* pool);

// 获取线程池中活着的线程的个数
int threadPoolAliveNum(ThreadPool* pool);

//////////////////////
// 工作的线程(消费者线程)任务函数
void* worker(void* arg);
// 管理者线程任务函数
void* manager(void* arg);
// 单个线程退出
void threadExit(ThreadPool* pool);
#endif  // _THREADPOOL_H
```

## 9.5 源文件定义

```c
ThreadPool* threadPoolCreate(int min, int max, int queueSize)
{
    ThreadPool* pool = (ThreadPool*)malloc(sizeof(ThreadPool));
    do 
    {
        if (pool == NULL)
        {
            printf("malloc threadpool fail...\n");
            break;
        }

        pool->threadIDs = (pthread_t*)malloc(sizeof(pthread_t) * max);
        if (pool->threadIDs == NULL)
        {
            printf("malloc threadIDs fail...\n");
            break;
        }
        memset(pool->threadIDs, 0, sizeof(pthread_t) * max);
        pool->minNum = min;
        pool->maxNum = max;
        pool->busyNum = 0;
        pool->liveNum = min;    // 和最小个数相等
        pool->exitNum = 0;

        if (pthread_mutex_init(&pool->mutexPool, NULL) != 0 ||
            pthread_mutex_init(&pool->mutexBusy, NULL) != 0 ||
            pthread_cond_init(&pool->notEmpty, NULL) != 0 ||
            pthread_cond_init(&pool->notFull, NULL) != 0)
        {
            printf("mutex or condition init fail...\n");
            break;
        }

        // 任务队列
        pool->taskQ = (Task*)malloc(sizeof(Task) * queueSize);
        pool->queueCapacity = queueSize;
        pool->queueSize = 0;
        pool->queueFront = 0;
        pool->queueRear = 0;

        pool->shutdown = 0;

        // 创建线程
        pthread_create(&pool->managerID, NULL, manager, pool);
        for (int i = 0; i < min; ++i)
        {
            pthread_create(&pool->threadIDs[i], NULL, worker, pool);
        }
        return pool;
    } while (0);

    // 释放资源
    if (pool && pool->threadIDs) free(pool->threadIDs);
    if (pool && pool->taskQ) free(pool->taskQ);
    if (pool) free(pool);

    return NULL;
}

int threadPoolDestroy(ThreadPool* pool)
{
    if (pool == NULL)
    {
        return -1;
    }

    // 关闭线程池
    pool->shutdown = 1;
    // 阻塞回收管理者线程
    pthread_join(pool->managerID, NULL);
    // 唤醒阻塞的消费者线程
    for (int i = 0; i < pool->liveNum; ++i)
    {
        pthread_cond_signal(&pool->notEmpty);
    }
    // 释放堆内存
    if (pool->taskQ)
    {
        free(pool->taskQ);
    }
    if (pool->threadIDs)
    {
        free(pool->threadIDs);
    }

    pthread_mutex_destroy(&pool->mutexPool);
    pthread_mutex_destroy(&pool->mutexBusy);
    pthread_cond_destroy(&pool->notEmpty);
    pthread_cond_destroy(&pool->notFull);

    free(pool);
    pool = NULL;

    return 0;
}


void threadPoolAdd(ThreadPool* pool, void(*func)(void*), void* arg)
{
    pthread_mutex_lock(&pool->mutexPool);
    while (pool->queueSize == pool->queueCapacity && !pool->shutdown)
    {
        // 阻塞生产者线程
        pthread_cond_wait(&pool->notFull, &pool->mutexPool);
    }
    if (pool->shutdown)
    {
        pthread_mutex_unlock(&pool->mutexPool);
        return;
    }
    // 添加任务
    pool->taskQ[pool->queueRear].function = func;
    pool->taskQ[pool->queueRear].arg = arg;
    pool->queueRear = (pool->queueRear + 1) % pool->queueCapacity;
    pool->queueSize++;

    pthread_cond_signal(&pool->notEmpty);
    pthread_mutex_unlock(&pool->mutexPool);
}

int threadPoolBusyNum(ThreadPool* pool)
{
    pthread_mutex_lock(&pool->mutexBusy);
    int busyNum = pool->busyNum;
    pthread_mutex_unlock(&pool->mutexBusy);
    return busyNum;
}

int threadPoolAliveNum(ThreadPool* pool)
{
    pthread_mutex_lock(&pool->mutexPool);
    int aliveNum = pool->liveNum;
    pthread_mutex_unlock(&pool->mutexPool);
    return aliveNum;
}

void* worker(void* arg)
{
    ThreadPool* pool = (ThreadPool*)arg;

    while (1)
    {
        pthread_mutex_lock(&pool->mutexPool);
        // 当前任务队列是否为空
        while (pool->queueSize == 0 && !pool->shutdown)
        {
            // 阻塞工作线程
            pthread_cond_wait(&pool->notEmpty, &pool->mutexPool);

            // 判断是不是要销毁线程
            if (pool->exitNum > 0)
            {
                pool->exitNum--;
                if (pool->liveNum > pool->minNum)
                {
                    pool->liveNum--;
                    pthread_mutex_unlock(&pool->mutexPool);
                    threadExit(pool);
                }
            }
        }

        // 判断线程池是否被关闭了
        if (pool->shutdown)
        {
            pthread_mutex_unlock(&pool->mutexPool);
            threadExit(pool);
        }

        // 从任务队列中取出一个任务
        Task task;
        task.function = pool->taskQ[pool->queueFront].function;
        task.arg = pool->taskQ[pool->queueFront].arg;
        // 移动头结点
        pool->queueFront = (pool->queueFront + 1) % pool->queueCapacity;
        pool->queueSize--;
        // 解锁
        pthread_cond_signal(&pool->notFull);
        pthread_mutex_unlock(&pool->mutexPool);

        printf("thread %ld start working...\n", pthread_self());
        pthread_mutex_lock(&pool->mutexBusy);
        pool->busyNum++;
        pthread_mutex_unlock(&pool->mutexBusy);
        task.function(task.arg);
        free(task.arg);
        task.arg = NULL;

        printf("thread %ld end working...\n", pthread_self());
        pthread_mutex_lock(&pool->mutexBusy);
        pool->busyNum--;
        pthread_mutex_unlock(&pool->mutexBusy);
    }
    return NULL;
}

void* manager(void* arg)
{
    ThreadPool* pool = (ThreadPool*)arg;
    while (!pool->shutdown)
    {
        // 每隔3s检测一次
        sleep(3);

        // 取出线程池中任务的数量和当前线程的数量
        pthread_mutex_lock(&pool->mutexPool);
        int queueSize = pool->queueSize;
        int liveNum = pool->liveNum;
        pthread_mutex_unlock(&pool->mutexPool);

        // 取出忙的线程的数量
        pthread_mutex_lock(&pool->mutexBusy);
        int busyNum = pool->busyNum;
        pthread_mutex_unlock(&pool->mutexBusy);

        // 添加线程
        // 任务的个数>存活的线程个数 && 存活的线程数<最大线程数
        if (queueSize > liveNum && liveNum < pool->maxNum)
        {
            pthread_mutex_lock(&pool->mutexPool);
            int counter = 0;
            for (int i = 0; i < pool->maxNum && counter < NUMBER
                && pool->liveNum < pool->maxNum; ++i)
            {
                if (pool->threadIDs[i] == 0)
                {
                    pthread_create(&pool->threadIDs[i], NULL, worker, pool);
                    counter++;
                    pool->liveNum++;
                }
            }
            pthread_mutex_unlock(&pool->mutexPool);
        }
        // 销毁线程
        // 忙的线程*2 < 存活的线程数 && 存活的线程>最小线程数
        if (busyNum * 2 < liveNum && liveNum > pool->minNum)
        {
            pthread_mutex_lock(&pool->mutexPool);
            pool->exitNum = NUMBER;
            pthread_mutex_unlock(&pool->mutexPool);
            // 让工作的线程自杀
            for (int i = 0; i < NUMBER; ++i)
            {
                pthread_cond_signal(&pool->notEmpty);
            }
        }
    }
    return NULL;
}

void threadExit(ThreadPool* pool)
{
    pthread_t tid = pthread_self();
    for (int i = 0; i < pool->maxNum; ++i)
    {
        if (pool->threadIDs[i] == tid)
        {
            pool->threadIDs[i] = 0;
            printf("threadExit() called, %ld exiting...\n", tid);
            break;
        }
    }
    pthread_exit(NULL);
}
```

## 9.6 测试代码

```c
void taskFunc(void* arg)
{
    int num = *(int*)arg;
    printf("thread %ld is working, number = %d\n",
        pthread_self(), num);
    sleep(1);
}

int main()
{
    // 创建线程池
    ThreadPool* pool = threadPoolCreate(3, 10, 100);
    for (int i = 0; i < 100; ++i)
    {
        int* num = (int*)malloc(sizeof(int));
        *num = i + 100;
        threadPoolAdd(pool, taskFunc, num);
    }

    sleep(30);

    threadPoolDestroy(pool);
    return 0;
}
```

# 十、线程池——C改C++版

对这些代码做从C到C++的迁移主要用到了C++三大特性中的封装，因此难度不大，对应C++初学者来说有助于提高编码水平和对面向对象的理解，对于熟练掌握了C++的人来说就是`张飞吃豆芽 -- 小菜一碟（so easy）`。

关于线程的在此就不再过多阐述，对于[前面文章](https://subingwen.cn/linux/threadpool/)中设计的线程池，按照面向对象的思想进行拆分可以分为两部分（纯属个人见解，有不同的想法也正常）：`任务队列类` 和`线程池类`。

## 10.1 任务队列

### 10.1.1 类声明

```c++
// 定义任务结构体
using callback = void(*)(void*);
struct Task
{
    Task()
    {
        function = nullptr;
        arg = nullptr;
    }
    Task(callback f, void* arg)
    {
        function = f;
        this->arg = arg;
    }
    callback function;
    void* arg;
};

// 任务队列
class TaskQueue
{
public:
    TaskQueue();
    ~TaskQueue();

    // 添加任务
    void addTask(Task& task);
    void addTask(callback func, void* arg);

    // 取出一个任务
    Task takeTask();

    // 获取当前队列中任务个数
    inline int taskNumber()
    {
        return m_queue.size();
    }

private:
    pthread_mutex_t m_mutex;    // 互斥锁
    std::queue<Task> m_queue;   // 任务队列
};
```

其中`Task`是任务类，里边有两个成员，分别是两个指针`void(*)(void*)`和`void*`

另外一个类`TaskQueue`是任务队列，提供了添加任务、取出任务、存储任务、获取任务个数、线程同步的功能。

### 10.1.2 类定义

```c++
TaskQueue::TaskQueue()
{
    pthread_mutex_init(&m_mutex, NULL);
}

TaskQueue::~TaskQueue()
{
    pthread_mutex_destroy(&m_mutex);
}

void TaskQueue::addTask(Task& task)
{
    pthread_mutex_lock(&m_mutex);
    m_queue.push(task);
    pthread_mutex_unlock(&m_mutex);
}

void TaskQueue::addTask(callback func, void* arg)
{
    pthread_mutex_lock(&m_mutex);
    Task task;
    task.function = func;
    task.arg = arg;
    m_queue.push(task);
    pthread_mutex_unlock(&m_mutex);
}

Task TaskQueue::takeTask()
{
    Task t;
    pthread_mutex_lock(&m_mutex);
    if (m_queue.size() > 0)
    {
        t = m_queue.front();
        m_queue.pop();
    }
    pthread_mutex_unlock(&m_mutex);
    return t;
}
```

## 10.2 线程池

### 10.2.1 类声明

```c++
class ThreadPool
{
public:
    ThreadPool(int min, int max);
    ~ThreadPool();

    // 添加任务
    void addTask(Task task);
    // 获取忙线程的个数
    int getBusyNumber();
    // 获取活着的线程个数
    int getAliveNumber();

private:
    // 工作的线程的任务函数
    static void* worker(void* arg);
    // 管理者线程的任务函数
    static void* manager(void* arg);
    void threadExit();

private:
    pthread_mutex_t m_lock;
    pthread_cond_t m_notEmpty;
    pthread_t* m_threadIDs;
    pthread_t m_managerID;
    TaskQueue* m_taskQ;
    int m_minNum;
    int m_maxNum;
    int m_busyNum;
    int m_aliveNum;
    int m_exitNum;
    bool m_shutdown = false;
};
```

### 10.2.2 类定义

```c++
ThreadPool::ThreadPool(int minNum, int maxNum)
{
    // 实例化任务队列
    m_taskQ = new TaskQueue;
    do {
        // 初始化线程池
        m_minNum = minNum;
        m_maxNum = maxNum;
        m_busyNum = 0;
        m_aliveNum = minNum;

        // 根据线程的最大上限给线程数组分配内存
        m_threadIDs = new pthread_t[maxNum];
        if (m_threadIDs == nullptr)
        {
            cout << "malloc thread_t[] 失败...." << endl;;
            break;
        }
        // 初始化
        memset(m_threadIDs, 0, sizeof(pthread_t) * maxNum);
        // 初始化互斥锁,条件变量
        if (pthread_mutex_init(&m_lock, NULL) != 0 ||
            pthread_cond_init(&m_notEmpty, NULL) != 0)
        {
            cout << "init mutex or condition fail..." << endl;
            break;
        }

        /////////////////// 创建线程 //////////////////
        // 根据最小线程个数, 创建线程
        for (int i = 0; i < minNum; ++i)
        {
            pthread_create(&m_threadIDs[i], NULL, worker, this);
            cout << "创建子线程, ID: " << to_string(m_threadIDs[i]) << endl;
        }
        // 创建管理者线程, 1个
        pthread_create(&m_managerID, NULL, manager, this);
    } while (0);
}

ThreadPool::~ThreadPool()
{
    m_shutdown = 1;
    // 销毁管理者线程
    pthread_join(m_managerID, NULL);
    // 唤醒所有消费者线程
    for (int i = 0; i < m_aliveNum; ++i)
    {
        pthread_cond_signal(&m_notEmpty);
    }

    if (m_taskQ) delete m_taskQ;
    if (m_threadIDs) delete[]m_threadIDs;
    pthread_mutex_destroy(&m_lock);
    pthread_cond_destroy(&m_notEmpty);
}

void ThreadPool::addTask(Task task)
{
    if (m_shutdown)
    {
        return;
    }
    // 添加任务，不需要加锁，任务队列中有锁
    m_taskQ->addTask(task);
    // 唤醒工作的线程
    pthread_cond_signal(&m_notEmpty);
}

int ThreadPool::getAliveNumber()
{
    int threadNum = 0;
    pthread_mutex_lock(&m_lock);
    threadNum = m_aliveNum;
    pthread_mutex_unlock(&m_lock);
    return threadNum;
}

int ThreadPool::getBusyNumber()
{
    int busyNum = 0;
    pthread_mutex_lock(&m_lock);
    busyNum = m_busyNum;
    pthread_mutex_unlock(&m_lock);
    return busyNum;
}


// 工作线程任务函数
void* ThreadPool::worker(void* arg)
{
    ThreadPool* pool = static_cast<ThreadPool*>(arg);
    // 一直不停的工作
    while (true)
    {
        // 访问任务队列(共享资源)加锁
        pthread_mutex_lock(&pool->m_lock);
        // 判断任务队列是否为空, 如果为空工作线程阻塞
        while (pool->m_taskQ->taskNumber() == 0 && !pool->m_shutdown)
        {
            cout << "thread " << to_string(pthread_self()) << " waiting..." << endl;
            // 阻塞线程
            pthread_cond_wait(&pool->m_notEmpty, &pool->m_lock);

            // 解除阻塞之后, 判断是否要销毁线程
            if (pool->m_exitNum > 0)
            {
                pool->m_exitNum--;
                if (pool->m_aliveNum > pool->m_minNum)
                {
                    pool->m_aliveNum--;
                    pthread_mutex_unlock(&pool->m_lock);
                    pool->threadExit();
                }
            }
        }
        // 判断线程池是否被关闭了
        if (pool->m_shutdown)
        {
            pthread_mutex_unlock(&pool->m_lock);
            pool->threadExit();
        }

        // 从任务队列中取出一个任务
        Task task = pool->m_taskQ->takeTask();
        // 工作的线程+1
        pool->m_busyNum++;
        // 线程池解锁
        pthread_mutex_unlock(&pool->m_lock);
        // 执行任务
        cout << "thread " << to_string(pthread_self()) << " start working..." << endl;
        task.function(task.arg);
        delete task.arg;
        task.arg = nullptr;

        // 任务处理结束
        cout << "thread " << to_string(pthread_self()) << " end working...";
        pthread_mutex_lock(&pool->m_lock);
        pool->m_busyNum--;
        pthread_mutex_unlock(&pool->m_lock);
    }

    return nullptr;
}


// 管理者线程任务函数
void* ThreadPool::manager(void* arg)
{
    ThreadPool* pool = static_cast<ThreadPool*>(arg);
    // 如果线程池没有关闭, 就一直检测
    while (!pool->m_shutdown)
    {
        // 每隔5s检测一次
        sleep(5);
        // 取出线程池中的任务数和线程数量
        //  取出工作的线程池数量
        pthread_mutex_lock(&pool->m_lock);
        int queueSize = pool->m_taskQ->taskNumber();
        int liveNum = pool->m_aliveNum;
        int busyNum = pool->m_busyNum;
        pthread_mutex_unlock(&pool->m_lock);

        // 创建线程
        const int NUMBER = 2;
        // 当前任务个数>存活的线程数 && 存活的线程数<最大线程个数
        if (queueSize > liveNum && liveNum < pool->m_maxNum)
        {
            // 线程池加锁
            pthread_mutex_lock(&pool->m_lock);
            int num = 0;
            for (int i = 0; i < pool->m_maxNum && num < NUMBER
                && pool->m_aliveNum < pool->m_maxNum; ++i)
            {
                if (pool->m_threadIDs[i] == 0)
                {
                    pthread_create(&pool->m_threadIDs[i], NULL, worker, pool);
                    num++;
                    pool->m_aliveNum++;
                }
            }
            pthread_mutex_unlock(&pool->m_lock);
        }

        // 销毁多余的线程
        // 忙线程*2 < 存活的线程数目 && 存活的线程数 > 最小线程数量
        if (busyNum * 2 < liveNum && liveNum > pool->m_minNum)
        {
            pthread_mutex_lock(&pool->m_lock);
            pool->m_exitNum = NUMBER;
            pthread_mutex_unlock(&pool->m_lock);
            for (int i = 0; i < NUMBER; ++i)
            {
                pthread_cond_signal(&pool->m_notEmpty);
            }
        }
    }
    return nullptr;
}

// 线程退出
void ThreadPool::threadExit()
{
    pthread_t tid = pthread_self();
    for (int i = 0; i < m_maxNum; ++i)
    {
        if (m_threadIDs[i] == tid)
        {
            cout << "threadExit() function: thread " 
                << to_string(pthread_self()) << " exiting..." << endl;
            m_threadIDs[i] = 0;
            break;
        }
    }
    pthread_exit(NULL);
}
```













































